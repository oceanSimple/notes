# ♾️进程与线程
## 💫进程与线程
> 进程

1. 进程实体（进程映像）：由程序段-静态代码、相关数据段-运行变量、PCB组成
2. 进程映像是静态的，进程是动态的
3. PCB是进程存在的唯一标志

定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
进程的特征：动态、并发、独立、异步

进程的状态：
![[Pasted image 20240520113546.png]]
- 运行态到阻塞态是主动行为
- 阻塞态到就绪态是被动行为，需要其他进程唤醒

> 进程控制

创建过程：
1. 分配进程标识号，申请空白PCB
2. 为进程分配运行需要的资源
3. 初始化PCB
4. 放入就绪队列

终止事件：正常结束；触发异常；外界干预
终止过程：
1. 根据PID找到PCB
2. 中止该进程和其子进程
3. 释放全部资源
4. 删除PCB

阻塞过程：
1. 找到PCB
2. 改成阻塞态
3. 把PCB插入相应事件的等待队列

唤醒过程：
1. 在等待队列找到PCB
2. 阻塞态改成就绪态，并将其从等待队列移到就绪队列

> 进程通信

1. 共享存储
2. 消息传递：直接通信/间接通信
3. 管道通信：管道只能由创建进程访问。

> 线程

- 引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能
- 线程是基本的CPU执行单元。
- 进程只作为除CPU外的系统资源的分配单元，线程是处理机的分配单元

> 线程的实现方式

用户级线程：
- 有关线程的管理都有引用程序在用户空间完成，内核意识不到线程的存在
- 优点
	- 线程切换不需要切换到内核空间，节省开销
	- 调度算法可以由进程自定义
	- 实现与操作系统无关
- 缺点
	- 一个线程阻塞，整个进程内的所有线程全部阻塞
	- 每次分配给一个进程的只能有一个处理机，无法利用多核处理

内核级线程
- 内核空间为每个内核级线程设置一个线程控制块
- 优点
	- 能发挥多处理机的优势
	- 调度更方便
- 缺点
	- 需要到核心态进行切换

> 多线程模型

![[Pasted image 20240520121452.png]]

## 💫处理机调度
> 处理机的三级调度


![[Pasted image 20240521114142.png]]
- 高级调度/作业调度：内存与辅存之间的调度。每个作业只调入一次，调出一次
- 中级调度/内存调度：将暂时不能运行的进程调至外存等待，即挂起。需要时重新调回内存
- 低级调度/进程调度：分配cpu

> 调度优劣的指标

- CPU利用率：有效工作时间/（有效工作时间+空闲等待时间）
- 系统吞吐量
- 周转时间：作业完成时间-作业提交时间
- 带权周转时间：作业周转时间/作业实际运行时间
- 等待时间：衡量调度算法最简单的指标
- 响应时间：衡量交互系统的指标

> 调度时机

不进行进程调度和切换的情况
- 处理中断的过程
- 进程在操作系统内核临界区
- 其他需要完全屏蔽中断的原子操作

应该进行调度和切换的情况
- 发生调度条件且当前进程无法继续进行
- 中断结束或自陷处理结束

> 调度算法

1. FCFS
2. SJF-短作业优先：平均等待时间、平均周转时间最短
3. 优先级调度
4. 高响应比优先调度：（等待时间+要求服务时间）/要求服务时间
5. 时间片轮转
6. 多级队列调度
7. 多级反馈队列
![[Pasted image 20240521115511.png]]

## 💫同步与互斥
> 基本概念

- 临界资源：一次仅允许一个进程使用的资源
- 临界区：访问临界资源的代码
- 同步/直接制约关系：进程间需要按顺序执行
- 互斥/间接制约关系：都需要访问临界资源

> 实现临界区互斥的方法

- 软件实现
	- 单标志
		![[Pasted image 20240522113745.png]]
	- 双标志
		![[Pasted image 20240522113805.png]]
	- 双标志后检查：可能导致饥饿
		![[Pasted image 20240522113824.png]]
	- Peterson's Algorithm
		![[Pasted image 20240522113844.png]]
- 硬件实现
	- 中断屏蔽：屏蔽中断操作，不允许打扰该进程
	- 硬件指令：即原子操作

> 互斥锁

> 信号量

> 管程

- 代表共享资源的数据结构，以及对该共享数据结构实时操作的一组过程所组成的资源管理程序
	- 管程把对共享资源的操作封装了起来
	- 每次仅允许一个进程进入管程，从而实现互斥

> 经典同步问题

- 生产者-消费者
- 读者-写者问题
- 哲学家进餐问题
- 吸烟者问题

## 💫死锁
> 概念

- 死锁，指多个进程因竞争资源而造成的互相等待的僵局，若无外力作用，这些进程无法向前推进
- 产生原因：系统资源竞争；进程推进顺序非法

产生死锁的必要条件
- 互斥
- 不剥夺
- 请求并保存
- 循环等待

处理策略
- 死锁预防：破坏四个必要条件
- 避免死锁：避免系统进入不安全状态。银行家算法
- 死锁检测及解除：资源分配图
