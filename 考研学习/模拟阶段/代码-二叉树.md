# â™¾ï¸äºŒå‰æ ‘
## ğŸ’« å‰åº+ä¸­åº=åˆ›å»ºæ ‘
```c
BiTree *createBiTree(char preOrder[], int preFirst, int preLast, char inOrder[], int inFirst, int inLast) {
	// é€’å½’ä¸­æ­¢æ¡ä»¶
	if(preFirst > preLast) {
		return NULL;
	}
	
	// åˆ›å»ºä¸€ä¸ªBiTreeç»“ç‚¹
	BiTree *biTree = (BiTree *)malloc(sizeof(BiTree));
	// å°†preFirstå¤„å¾—ç»“ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹
	bitree->data = preOrder[preFirst];
	
	// æ‰¾åˆ°æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†ä¸­çš„ä¸‹æ ‡
	int index = inFirst; // ç®—æ³•ä¿è¯æ ¹èŠ‚ç‚¹è‚¯å®šåœ¨inFirstå’ŒinLastä¹‹é—´
	for(; index <= inLast; index++) {
		if(inOrder[index] == bitree->data) {
			break;
		}
	}
	
	// æ‰¾æ ¹èŠ‚ç‚¹çš„å·¦æ ‘
	biTree->lTree = createBiTree(preOrder, preFirst + 1, preFirst + (index - inFirst),
									inOrder, inFirst, index - 1);
	// æ‰¾æ ¹èŠ‚ç‚¹çš„å³æ ‘
	biTree->rTree = createBiTree(preOrder, preFIrst + (index-inFirst) + 1, preLast,
									inOrder, index+1, inLast);
	
	return biTree;
}
```

## ğŸ’«æŸ¥æ‰¾äºŒå‰æ ‘ä¸­çš„æŸä¸ªç»“ç‚¹
```c
BTree *seekTree(BTree *T, ElemType *x) {
	if(T==NULL) return NULL;
	if(x == T->data) return T;
	else {
		BTree *temp = seekTree(T->lchild, x);
		if(NULL != temp) return temp;
		else return seekTree(T->rchild, x);
	}
}
```


## ğŸ’«äºŒå‰æ ‘æ·±åº¦
```c
int getHeight(BTree T) {
	if(T == NULL) {
		return 0;
	}
	
	int leftH = getHeight(T->lChild);
	int rightH = getHeight(T->rChild);
	return leftH>rightH ? leftH+1 : rightH+1;
}
```

## ğŸ’«äº¤æ¢å·¦å³å­æ ‘
```c
void switchLRChild(BTree *T) {
	if(T == NULL) return;
	
	BTree *temp = T->lchild;
	T->lchild = T->rchild;
	T->rchild = temp;
	
	switchLRChild(T->lchild);
	switchLRChild(T->rchild);
}
```

## ğŸ’«åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ç›¸ä¼¼
```c
int similar(BTree *t1, BTree *t2) {
	if(t1 == NULL && t2 == NULL)
		return 1;
		
	if((t1 == NULL && t2 != NULL) || (t1 != NULL && t2 == NULL))
		return 0;
		
	return similar(t1->lchild, t2->lchild) && similar(t1->rchild, t2->rchild);
}
```

## ğŸ’«11. æ²¡çœ‹æ‡‚

## ğŸ’«12. äºŒå‰æ ‘è¡¨ç¤ºçš„äºŒå…ƒè¿ç®—è¡¨è¾¾å¼, è®¡ç®—å€¼
> è¿™æ£µæ ‘ç†è®ºä¸Š,
> - æœ‰å­©å­ç»“ç‚¹çš„ç»“ç‚¹ä¸€å®šåŒæ—¶æœ‰å·¦å³å­©å­
> - åˆ¤æ–­æ ‘éç©º, å½“ä¸”ä»…å½“æ ¹ä¸ºNULLæ—¶æ‰ä¼šè§¦å‘
```c
int operate(char operation, int left, int right) {
	switch(operation) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
	}
}

int getResult(BTree *T) {
	// ç©ºç»“ç‚¹, å½“0å¤„ç†
	if(T == NULL) return 0;
	
	// è¿ç®—ç¬¦ç»“ç‚¹, è®¡ç®—å·¦å³å­æ ‘çš„è¿ç®—ç»“æœ
	if(T->lchild != NULL && T->rchild != NULL) {
		int leftNum = getResult(T->lchild);
		int rightNum = getResult(T->rchild);
		return operate(T->data, leftNum, rightNum);
	}
	
	// å¶å­èŠ‚ç‚¹, ç›´æ¥è¿”å›æ•°å­—å­—ç¬¦çš„å€¼
	return T->data - '0'
}
```


## ğŸ’«13. åˆ¤æ–­æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘
> - å±‚åºéå†
> - å½“è®¿é—®åˆ°ç¬¬ä¸€ä¸ªNULLå, åç»­Queueä¸­ä¸èƒ½å­˜åœ¨éNULLçš„æ ‘!
```c
int judge(BTree *T) {
	Queue Q;
	InitQ(Q);
	EnQueue(Q, T);
	
	while(!IsEmptyQueue(Q)) {
		BTree *temp = NULL;
		DeQueue(Q, &e);
		
		if(e == NULL) break;
		
		EnQueue(Q, e->lchild);
		EnQueue(Q, e->rchild);
	}
	
	// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º, æˆ–è€…æ˜¯å¦å‰©ä¸‹çš„å…¨æ˜¯NULL
	while(!IsEmptyQueue(Q)) {
		BTree *temp = NULL;
		DeQueue(Q, &e);
		
		if(e != NULL) return 0;
	}
	
	return 1;
}
```

## ğŸ’«14. æ ‘çš„æœ€å¤§å®½åº¦
> - å±‚åºéå†


# â™¾ï¸äºŒå‰æ’åºæ ‘
## ğŸ’«15. æ„é€ äºŒå‰æ’åºæ ‘
```c
void insertKey(BTree *T, char data) {
	if(T == NULL) {
		BTree *temp = (BTree *)malloc(sizeof(BTree));
		temp->data = data;
		temp ->lchild = NULL;
		temp ->rchild = NULL;
		T = temp;
	}
	
	if(data > T->data)
		insertKey(T->rchild, data);
	else if(data < T->data)
		insertKey(T->lchild, data);
}
```

## ğŸ’«16. æŸ¥æ‰¾ç»“ç‚¹xæ‰€åœ¨å±‚æ•°
```c
int level = 0;

int getNode(BTree *T, int x) {
	if(T == NULL) return 0;
	
	level++;
	if(T->data == x)
		return level;
	else if(x > T->data)
		getNode(T->rchild, x);
	else
		getNode(T->lchild, x);
}
```

## ğŸ’«17. åˆ é™¤ç»“ç‚¹
> åˆ é™¤ç»“ç‚¹çš„å››ç§æƒ…å†µ
> - æ— å·¦å³å­©å­: ç›´æ¥å°†è¯¥èŠ‚ç‚¹ç½®ç©º
> - æ— å·¦, æœ‰å³: T = æœ‰å­©å­
> - æœ‰å·¦, æ— å³: T = å·¦å­©å­
> - *æœ‰å·¦, æœ‰å³*: æ‰¾åˆ°å·¦å­©å­ä¸­çš„æœ€å¤§ç»“ç‚¹, å°†Tçš„å³å­©å­æŒ‚åˆ°è¯¥èŠ‚ç‚¹çš„å³å­©å­ä¸Š, T = å·¦å­©å­

```c
void delete(BTree *T) {
	if(T->lchild == NULL && T->rchild == NULL)
		T = NULL;
	else if(T->lchild == NULL && T->rchild != NULL)
		T = T->rchild;
	else if(T->lchild != NULL && T->rchild == NULL)
		T = T->lchild;
	else {
		// å°†Tç»“ç‚¹çš„å³å­©å­, æŒ‚åˆ°å·¦å­©å­ä¸­çš„æœ€å¤§ç»“ç‚¹çš„å³èŠ‚ç‚¹ä¸Š.
		BTree *p = T->lchild;
		while(p->rchild != NULL) 
			p = p->rchild;
			
		p->rchild = T->rchild;
		T = T->lchild;
	}
}


void DFS(BTree *T, int x) {
	if(T == NULL) return;
	
	if(T->data == x) 
		delete(T);
	else if(x > T->data) 
		DFS(T->rchild, x);
	else 
		DFS(T->lchild, x);
}
```



## ğŸ’«18. å°äºkçš„æ‰€æœ‰ç»“ç‚¹(ç»ˆæ­¢æ¡ä»¶åˆ¤æ–­)
> ä¸­åºéå†, å³ä»å°åˆ°å¤§æ’åˆ—

```c
void DFS(BTree *T, int k) {
	if(T == NULL) return;
	
	DFS(T->lchild, k);
	if(T->data <= data) {
		printf("%d ", T->data);
		DFS(T->rchild, k);
	}
}
```

## ğŸ’«19. ***
é¢˜ç›®: å°†ä¸€é¢—äºŒå‰æ’åºæ ‘t, åˆ†æˆä¸¤é¢—æ ‘t1, t2. t1ä¸­æ‰€æœ‰ç»“ç‚¹å°äºx, t2ä¸­æ‰€æœ‰èŠ‚ç‚¹å¤§äºx
> - å…ˆåºéå†
> - æ ¹èŠ‚ç‚¹ > x, æ ¹èŠ‚ç‚¹ + rchild åŠ å…¥åˆ°t2, é€’å½’å·¦å­æ ‘
> - æ ¹èŠ‚ç‚¹ = x, lchild åŠ å…¥ t1, rchildåŠ å…¥t2, return
> - æ ¹èŠ‚ç‚¹ < x, æ ¹èŠ‚ç‚¹ + lchild åŠ å…¥åˆ°t1, é€’å½’å³å­æ ‘

```c
void insert(BTree *root, BTree *pNode) {
	if(root == NULL)
		root = pNode;
	else if(pNode->data > root->data)
		insert(root->rchild, pNode);
	else if(pNode->data < root->data)
		insert(root->lchild, pNode);
}

void preOrder(BTree *root, BTree *t1, BTree *t2, int x) {
	if(root == NULL)
		return;
		
	if(root->data > x) {
		preOrder(root->lchild, t1, t2, x);
		T->lchild = NULL;
		insert(t2, T)
	} else if(root->data == x) {
		insert(t1, root->lchild);
		insert(t2, root->rchild);
	} else if(root->data < x) {
		preOrder(root->rchild, t1, t2, x);
		T->rchild = NULL;
		insert(t1, T);
	}

}
```


## ğŸ’«20.
é¢˜ç›®: åˆ é™¤æ‰€æœ‰å°äºxçš„ç»“ç‚¹
> - å…ˆåºéå†
> - root > x, é€’å½’lchild
> - root = x, root = rchild
> - root < x, lchild = NULL, é€’å½’rchild

```c
// åˆ é™¤å¹¶é‡Šæ”¾æ ‘
void deleteBTree(BTree *T) {
	if(T == NULL) return;
	
	deleteBTree(T->lchild);
	deleteBTree(T->rchild);
	
	T->lchild = NULL;
	T->rchild = NULL;
	free(T);
	T = NULL;
}

void preOrder(BTree *T, int x) {
	if(T == NULL) return;
	
	if(T->data > x) {
		preOrder(T->lchild, x);
	} 
	else if(T->data == x) {
		delete(T->lchild);
		T->lchild = NULL;
	}
	else {
		deleteBTree(T->lchild);
		BTree *temp = T;
		T = T->rchild;
		preOrder(T, x);
		free(temp);
	}
}
```

## ğŸ’«21. è®¡ç®—æ¯ä¸ªç»“ç‚¹çš„å¹³è¡¡å› å­(æ·±åº¦å˜ç§)
> - è€ƒç‚¹åœ¨æ±‚æ·±åº¦
> - æ±‚å‡ºrootçš„å·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦, ç›¸å‡å³ä¸ºå¹³è¡¡å› å­
> - å¦‚æœbfçš„ç»å¯¹å€¼å¤§äºç­‰äº2, åˆ™å…¨å±€å˜é‡+1

```c
typedef struct BTree {
	int data;
	int bf;
	struct BTree *lchid, *rchild;
}BTree;

int getHeight(BTree *T) {
	if(T == NULL)
		return 0;
	
	int leftH = getHeight(T->lchid);
	int rightH = getHeight(T->rchild);
	return leftH > rightH ? leftH+1 : rightH+1;
}

int unbalanced = 0;
void solution(BTree *T) {
	if(T == NULL)
		return 0;
		
	int leftH = getHeight(T->lchild);
	int rightH = getHeight(T->rchild);
	
	T->bf = leftH - rightH;
	
	if(T->bf <= -2 || T->bf >= 2)
		unbalanced +=1;
		
	solution(T->lchild);
	solution(T->rchild);
}
```

## ğŸ’«22. (æ·±åº¦å˜ç§)
é¢˜ç›®: å‡è®¾å¹³è¡¡äºŒå‰æ ‘çš„æ¯ä¸ªç»“ç‚¹è¡¨æ˜äº†å¹³è¡¡å› å­, æ±‚å¹³è¡¡äºŒå‰æ ‘çš„é«˜åº¦
```c
typedef struct BTree {
	int data;
	int bf;
	struct BTree *lchid, *rchild;
}BTree;

int getHeight(BTree *T) {
	if(T == NULL)
		return 0;
	
	T->bf > 0 
	return T->bf > 0  ? getHeight(T->lchild)+1 : getHeight(T->rchild)+1;
}
```

# â™¾ï¸çº¿ç´¢äºŒå‰æ ‘
> ç»“æ„ä½“
```c
typedef strcut BiThrNode {
	char data;
	struct BiThrNode *lchild;
	int lTag;
	struct BiThrNode *rchild;
	int rTag;
}BiThrNode;
```

## ğŸ’«23. æ„é€ å…ˆåºçº¿ç´¢äºŒå‰æ ‘
```c
BThrNode *preNode = NULL;
void preOrderThreading(BThrNode *pNode) {
	if(pNode == NULL) return;

	// å¤„ç†å‰é©±
	if(pNode->lchild == NULL) {
		pNode->lchild = preNode;
		pNode->ltag = 1;
	}
	// å¤„ç†åç»§
	if(preNode == NULL && preNode->rchild == NULL) {
		preNode->rchild = pNode;
		preNode->rtag = 1;
	}
	// æ›´æ–°preNode
	preNode = pNode;
	
	if(pNode->ltag == 0)
		preOrderThreading(pNode->lchild);
	if(pNode->rtag == 0)
		preOrderThreading(pNode->rchild);
}
```


## ğŸ’«24. å…ˆåºéå†: å…ˆåºçº¿ç´¢äºŒå‰æ ‘(éé€’å½’ç®—æ³•)

