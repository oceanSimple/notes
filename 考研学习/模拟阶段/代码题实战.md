# ♾️计算机11
## 💫数据结构-3
```c
int visited[VERTEX_NUM_MAX] = {9};

void Solution(ALGragh G) {
	for(int i = 0; i < VERTEX_NUM_MAX; i++) {
		if (visited[i] == 0) {
			print("%d\n", G.vertex[i].data);
			DFS(G, G.vertex[i]);
		}
	}
}

void DFS(ALGragh G, Vertex v) {
	visit[v] = 1;
	AdjVertex *adj = v.firstAdj; // 第一个邻接结点
	while(NULL != adj) {
		if (visited[adj.index] == 0) {
			DFS(G, G.vertex[adj.index]);
		}
		adj = adj.next;
	}
}
```

# ♾️计算机13
## 💫数据结构-3
```c
int visited[VERTEX_NUM_MAX] = {0};
// 格式化visited数组
void EmptyVisited(int length) {
	for(int i = 0; i < length; i++) {
		visited[i] = 0;
	}
}
// 判断visited数组中的每个元素是否都为1
void JudgeIncludeAllVertex(int length) {
	for(int i = 0; i < length; i++) {
		if(visited[i] == 0) return 0;
	}
	return 1;
}
// DFS遍历
void DFS(ALGraph G, VertexType v) {
	visited[v] = 1;
	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}
}

int HasRoot(ALGraph G) {
	int length = G.verNum;
	// 遍历所有的结点
	for(int i = 0; i < G.vexNum; i++) {
		EmptyVisited(length); // 清空visited数组
		DFS(G, i);
		int flag = JudgeIncludeAllVertex(length);
		if (flag == 1) return 1;
		else print("%d\n", G.vertex[i].data);
	}
	return 0;
}
```

# ♾️计算机14
## 💫数据结构-3
```c
int visited[VERTEX_NUM_MAX] = {0};
int pathList[VERTEX_NUM_MAX] = {0};
int pathLength = 0;

void DFS(ALGraph G, Vertype v, Vertype dest, int len) {
	visited[v] = 1;
	pathList[v] = G.vertex[v];
	pathLength++;

	if(v == dest) {
		if (pathLength == len) printPath();
		else return;
	}

	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}

	visited[v] = 0;
	pathLength--;
}
```
