# â™¾ï¸æ€»ç»“
## ğŸ’«äºŒå‰æ ‘
### å‰åº+ä¸­åº=åˆ›å»ºæ ‘
```c
BiTree *createBiTree(char preOrder[], int preFirst, int preLast, char inOrder[], int inFirst, int inLast) {
	// é€’å½’ä¸­æ­¢æ¡ä»¶
	if(preFirst > preLast) {
		return NULL;
	}
	
	// åˆ›å»ºä¸€ä¸ªBiTreeç»“ç‚¹
	BiTree *biTree = (BiTree *)malloc(sizeof(BiTree));
	// å°†preFirstå¤„å¾—ç»“ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹
	bitree->data = preOrder[preFirst];
	
	// æ‰¾åˆ°æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†ä¸­çš„ä¸‹æ ‡
	int index = inFirst; // ç®—æ³•ä¿è¯æ ¹èŠ‚ç‚¹è‚¯å®šåœ¨inFirstå’ŒinLastä¹‹é—´
	for(; index <= inLast; index++) {
		if(inOrder[index] == bitree->data) {
			break;
		}
	}
	
	// æ‰¾æ ¹èŠ‚ç‚¹çš„å·¦æ ‘
	biTree->lTree = createBiTree(preOrder, preFirst + 1, preFirst + (index - inFirst),
									inOrder, inFirst, index - 1);
	// æ‰¾æ ¹èŠ‚ç‚¹çš„å³æ ‘
	biTree->rTree = createBiTree(preOrder, preFIrst + (index-inFirst) + 1, preLast,
									inOrder, index+1, inLast);
	
	return biTree;
}
```



## ğŸ’«ç»“æ„ä½“
### ListNode
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;
```

### é‚»æ¥è¡¨å›¾
```c
#define MAX_VERTEX_NUM 100  
  
typedef struct ArcNode {  
    int adjVex; // ç»“ç‚¹æ•°ç»„çš„ç´¢å¼•, ç”¨æ¥æŸ¥æ‰¾å…·ä½“çš„ç»“ç‚¹ä¿¡æ¯  
    struct ArcNode *nextArc;  
    int weight; // æƒé‡  
} ArcNode;  
  
typedef int VertexType;  
  
typedef struct VNode {  
    VertexType data;  
    ArcNode *firstArc; // ç¬¬ä¸€ä¸ªé‚»æ¥ç»“ç‚¹  
} VNode, AdjList[MAX_VERTEX_NUM];  
  
typedef struct {  
    AdjList vertices; // æ‰€æœ‰ç»“ç‚¹  
    int vexNum; // ç»“ç‚¹æ•°, ä¹Ÿå³verticesæ•°ç»„é•¿åº¦  
    int arcNum; // æ€»çš„å¼§æ•°  
    int kind; // å›¾çš„ç±»å‹  
} ALGraph;
```

## ğŸ’«æ–‡ä»¶å¤„ç†
### æ‰“å¼€æ–‡ä»¶
```c
	FILE *fp = fopen("1.txt", "r");
	if (fp == NULL) {
		perror("file open error");
		exit(1);
	}
	fclose(fp);
```

### è¯»å–ä¸€ä¸ªå­—ç¬¦
```c
	char buf;
	while(fscanf(fp, "%c%, &buf) > 0) {
		printf("%c", buf);
	}
```

### å†™æ–‡ä»¶
```c
void writeData(char dataList[][COLUMN_MAX], int dataLen) {
	FILE *fp = fopen("file2.txt", "w");
	if (fp != NULL) {
		for(int i = 0; i < dataLen; i++){
			fprintf(fp, "%s ", dataList[i]);
		}
	}
	fclose(fp);
}
```

## ğŸ’«å­—ç¬¦ä¸²æ“ä½œå‡½æ•°
- string.håŒ…
- æ¯”è¾ƒ: strcmp(s1, s2) : s1 > s2?
- å¤åˆ¶: strcpy(s1, s2) : s2èµ‹å€¼ç»™s1


## ğŸ’«å…¶ä»–
### malloce
```c
LNode *node = (LNode*)malloc(sizeof(LNode));
```

### strLen
```c
int strLen(char *str) {
	char *p = str;
	int strLen = 0;
	while(*p != '\0') {
		strLen++;
		p++;
	}
	return strLen;
}
```

### æŒ‡é’ˆéå†å­—ç¬¦ä¸²
```c
char *stuff(char *str1, char *str2, int i, int j) {
	int instance = j - 1 + 1;
	int str2Len = strlen(str2);
	if (distance != str2Len) {
		return 0;
	}
	char *p = str2;
	i = i-1; // å¯¹é½æ•°ç»„ä¸‹æ ‡
	while(i<=j-1) {
		*(str + i) = *p
		i++;
		p++;
	}
	return 1;
}
```

### å­—ç¬¦ä¸²å€’åºéå†

```c
int printUpper(char *str) {
	// å°†pæŒ‡é’ˆç§»åˆ°å­—ç¬¦ä¸²çš„æœ€å
	char *p = str;
	while((*p) != '\0') p++;
	
	// å€’å™éå†
	while(p >= str) {
		if(*p >= 'A' && *p <= 'Z')
			printf("%c", *p);
			
		p--;
	}
}
```


### ä»æ§åˆ¶å°è¯»å–è¾“å…¥
```c
int main(){
	int arr[100] = {0};
	int arrLen = 0;
	int temp_data;
	scanf("%d", &temp_data);
	while(temp_data != 0) {
		arr[arrLen] = temp_data;
		arrLen++;
		scanf("%d", &temp_data);
	}
	solution(arr, arrLen);
}
```


# â™¾ï¸è®¡ç®—æœº10
## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;
void printMin(LNode *head) {
	int min = head -> data;
	min = head->next->data < min ? head->next->data : min;
	min = head->next->next->data < min ? head->next->next->data : min;
	printf("%d", min);
}
int solution(LNode *head) {
	// ä¸´æ—¶æŒ‡é’ˆ
	LNode *p = head -> next;
	while ((p != NULL) && (p->next != NULL) && (p->next->next != NULL)) {
		int sum = p->next->data + p->next->next->data;
		if (sum != p->data) {
			printMin(p);
			return 0;
		}
		p = p->next;
	}
	printf("%d", head->next->data);
	return 1;
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[MAX_VERTEX_NUM] = {0};

void BFS(ALGraph G) {
	Stack s = InitStack();
	for (int i=0; i<G.vexNum; i++) {
		if(visited[i] == 0) {
			Push(s, G.vertices[i]);
			while(!IsEmpty(s)) { // å¦‚æœæ ˆéç©º, åˆ™å¾ªç¯
				VNode *temp = Pop(s);
				print("%d ", temp->data);
				visited[temp->data] = 1;
				
				ArcNode *p = temp -> firstArc;
				while (p != NULL) {
					if(visited[p->adjVex] == 0) {
						Push(s, G.vertices[p->adjVex])
					}
					p = p->nextArc;
				}
			}
		}
	}
}
```



# â™¾ï¸è®¡ç®—æœº11

## ğŸ’«c-1
```c
#include <stdio.h>

int main(){
	FILE *fp = fopen("1.txt", "r");
	if (fp == NULL) {
		perror("file open error");
		exit(1);
	}
	char buf;
	int count = 0;
	
	while(fscanf(fp, "%c%, &buf) > 0) {
		count++;
		printf("%c", buf);
		if(buf == '\n') {
			count = 0;
			continue;
		}
		if (count == 30) {
			printf("\n");
			count = 0;
		}
	}
	
	fclose(fp);
}
```

## ğŸ’«c-2
```c
#include <stdio.h>
#include <string.h>

int strLen(char *str) {
	char *p = str;
	int strLen = 0;
	while(*p != '\0') {
		strLen++;
		p++;
	}
	return strLen;
}

char *stuff(char *str1, char *str2, int i, int j) {
	int instance = j - 1 + 1;
	int str2Len = strlen(str2);
	if (distance != str2Len) {
		return 0;
	}
	char *p = str2;
	i = i-1; // å¯¹é½æ•°ç»„ä¸‹æ ‡
	while(i<=j-1) {
		*(str + i) = *p
		i++;
		p++;
	}
	return 1;
}
```

## ğŸ’«c-3
```c
#include <stdio.h>

#define ROW_NUM 3;
#define COLUMN_NUM 3;

int findRowMax(int arr[ROW_NUM][COLUMN_NUM],int i) {
	int max = 0;
	for(int j = 0; j< COLUMN_NUM; j++) {
		max = arr[i][j] > arr[i][max] ? arr[i][j] : arr[i][max];
	}
	return max;
}

int findRowMax(int arr[ROW_NUM][COLUMN_NUM],int row, int column) {
	for(int i = 0; i < ROW_NUM; i++) {
		if(arr[i][column] < arr[row][column])
			return 0;
	}
	return 1;
}

int findAnNode(int arr[ROW_NUM][COLUMN_NUM]) {
	// éå†è¡Œ
	for(int i = 0; i< ROW_NUM; i++) {
		int index = findRowMax(arr, i); // æ‰¾åˆ°è¡Œæœ€å¤§å€¼çš„åˆ—ä¸‹æ ‡ç´¢å¼•
		int flag = judgeIsCoulumnMin(arr, i, index); // åˆ¤æ–­æ˜¯å¦ä¸ºåˆ—æœ€å°
		if(flag == 1) {
			print("%d", arr[i][index]);
			return 1;
		}
	}
	return 0;
}
```

## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;

void insertIntoList(LNode *head, int data) {
	LNode *node = (LNode*)malloc(sizeof(LNode));
	node -> data = data;
	node -> next = NULL;
	
	LNode *slow = head;
	LNode *fast = head->next;
	while(fast == NULL || fast->data < data) {
		slow = slow->next;
		fast = fast->next;
	}
	
	slow->next = node;
	node->next = fast;
}

void printList(LNode *head) {
	LNode *index = head->next;
	while(index != NULL) {
		printf("%d\n", index->data)
		index = index->next
	}
}

LNode* solution(int arr[], int arrLen) {
	LNode *head = (LNode*)malloc(sizeof(LNode));
	head -> next = NULL;
	
	for(int i = 0; i < arrLen; i++){
		insertIntoList(head, arr[i]);
	}
	
	printList(head);
}

int main(){
	int arr[100] = {0};
	int arrLen = 0;
	int temp_data;
	scanf("%d", &temp_data);
	while(temp_data != 0) {
		arr[arrLen] = temp_data;
		arrLen++;
		scanf("%d", &temp_data);
	}
	solution(arr, arrLen);
}
```




## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {9};

void Solution(ALGragh G) {
	for(int i = 0; i < VERTEX_NUM_MAX; i++) {
		if (visited[i] == 0) {
			print("%d\n", G.vertex[i].data);
			DFS(G, G.vertex[i]);
		}
	}
}

void DFS(ALGragh G, Vertex v) {
	visit[v] = 1;
	AdjVertex *adj = v.firstAdj; // ç¬¬ä¸€ä¸ªé‚»æ¥ç»“ç‚¹
	while(NULL != adj) {
		if (visited[adj.index] == 0) {
			DFS(G, G.vertex[adj.index]);
		}
		adj = adj.next;
	}
}
```

# â™¾ï¸è®¡ç®—æœº13
## ğŸ’«c-1
```c
int longf(int n, int m) {
	if( m == 0 || m > n){
		return 0;
	}
	if( m == 1 || m == n){
		return 1;
	}
	return m + longf(n-1, m) - longf(n-1, m-1);
}
```

## ğŸ’«c-2
```c
#define ROW_LEN 3;
#define COLUMN_LEN 3;

int judge(int arr[][]){
	// æ£€æŸ¥è¡Œ
	for(int i = 0;i < ROW_LEN; i++){
		int sum = 0;
		for(int j=0; j< COLUMN_LEN; j++){
			sum+=arr[i][j];
		}
		if(sum != 15)
			return 0;
	}
	// æ£€æŸ¥åˆ—
	for(int i = 0;i < COLUMN_LEN; i++){
		int sum = 0;
		for(int j=0; j< ROW_LEN; j++){
			sum+=arr[j][i];
		}
		if(sum != 15)
			return 0;
	}
	// æ£€æŸ¥å¯¹è§’çº¿
	int leftLine = arr[1][1] + arr[2][2] + arr[3][3];
	int rightLine = arr[1][3] + arr[2][2] + arr[3][1];
	if((leftLine != 15) || (rightLine != 15))
		return 0;
		
	return 1;
}
```

## ğŸ’«c-3(è¯»å†™æ–‡ä»¶, å­—ç¬¦ä¸²æ’åº)
```c
#include <stdio.h>
#include <string.h>

#define ROW_MAX 50;
#define COLUMN_MAX 50;

int main() {
	char dataList[ROW_MAX][COLUMN_MAX];
	int dataLen = 0;
	readData(dataList, &dataLen);
	sortData(dataList, dataLen);
	writeData(dataList, dataLen);
}

void readData(char dataList[ROW_MAX][COLUMN_MAX], int *dataLen) {
	FILE *fp = fopen("file1.txt", "r");
	if (p != NULL) {
		while((fscanf(fp, "%s", dataList[*dataLen])) > 0) {
			*dataLen+=1;
		}
	}
	fclose(fp);
}

// å†’æ³¡æ’åº
void sortData(char dataList[][COLUMN_MAX], int dataLen) {
	for(int i = 0; i < dataLen; i++) {
		char temp[COLUMN_MAx];
		for(int j = 0; j < dataLen-1-i; j++) {
			if(strcmp(dataList[j], dataList[j+1]) > 0) {
				strcpy(temp, dataLit[j]);
				strcpy(dataList[j], dataList[j+1]);
				strcpy(dataList[j+1], temp);
			}
		}
	}
}

void writeData(char dataList[][COLUMN_MAX], int dataLen) {
	FILE *fp = fopen("file2.txt", "w");
	if (fp != NULL) {
		for(int i = 0; i < dataLen; i++){
			fprintf(fp, "%s ", dataList[i]);
		}
	}
	fclose(fp);
}
```


## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;

// 0: åˆ é™¤å¤±è´¥, 1: åˆ é™¤æˆåŠŸ
int solution(LNode *la, int i, int len) {
	LNode *slow = la;
	LNode *fast = la;
	// slowå’Œfastç›¸èšlenä¸ªèº«ä½
	for(int count = 0; count < len; count++) {
		if(fast == NULL)
			return 0; // é“¾è¡¨é•¿åº¦ä¸å¤Ÿ, åˆ é™¤å¤±è´¥
			
		fast = fast->next;
	}
	// ä½¿slowæŒ‡å‘ç¬¬iä¸ªå…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ , fastæŒ‡å‘ç¬¬i+len-1ä¸ªå…ƒç´ 
	for(int index = 1; index < i; index++) {
		slow = slow->next;
		fast = fast->next;
	}
	slow->next = fast->next;
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {0};
// æ ¼å¼åŒ–visitedæ•°ç»„
void EmptyVisited(int length) {
	for(int i = 0; i < length; i++) {
		visited[i] = 0;
	}
}
// åˆ¤æ–­visitedæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯å¦éƒ½ä¸º1
void JudgeIncludeAllVertex(int length) {
	for(int i = 0; i < length; i++) {
		if(visited[i] == 0) return 0;
	}
	return 1;
}
// DFSéå†
void DFS(ALGraph G, VertexType v) {
	visited[v] = 1;
	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}
}

int HasRoot(ALGraph G) {
	int length = G.verNum;
	// éå†æ‰€æœ‰çš„ç»“ç‚¹
	for(int i = 0; i < G.vexNum; i++) {
		EmptyVisited(length); // æ¸…ç©ºvisitedæ•°ç»„
		DFS(G, i);
		int flag = JudgeIncludeAllVertex(length);
		if (flag == 1) return 1;
		else print("%d\n", G.vertex[i].data);
	}
	return 0;
}
```

# â™¾ï¸è®¡ç®—æœº14
## ğŸ’«c-1
```c
#include <stdio.h>

int main() {
	int i = 0;
	while(1) {
		if( ((i%5)==1) && ((i%6)==5) && ((i%7)==4) && ((i%11)==10))
			break;
		i++;
	}
	printf("%d", i);
}
```

## ğŸ’«c-2
```c
#include <stdio.h>

int main() {
	char str[MAX_LEN];
	int big = 0;
	int small = 0;
	gets(str);
	count(str, &big, &small);
	printUpper(str);
}

int count(char *str, int *bigNumber, int *smallNumber) {
	char *p = str;
	while(p != '\0') {
		if(*p >= 'A' && *p <= 'Z')
			(*bigNumber)++;
		if(*p >= 'a' && *p <= 'z')
			(*smallNumber)++;
		p++;
	}
}

int printUpper(char *str) {
	// å°†pæŒ‡é’ˆç§»åˆ°å­—ç¬¦ä¸²çš„æœ€å
	char *p = str;
	while((*p) != '\0') p++;
	
	// å€’å™éå†
	while(p >= str) {
		if(*p >= 'A' && *p <= 'Z')
			printf("%c", *p);
			
		p--;
	}
}
```


## ğŸ’«æ•°æ®ç»“æ„-1
```c
void solution(int arr[], int len) {
	int left = 0;
	int right = len-1;
	while(left < right) {
		while( (left<right) && arr[left]<=0 )
			left++;
		while((left<right) && arr[right]>=0)
			right--;
			
		int temp = arr[left];
		arr[left] = arr[right];
		arr[right] = temp;
		
		left++;
		right--;
	}
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {0};
int pathList[VERTEX_NUM_MAX] = {0};
int pathLength = 0;

void DFS(ALGraph G, Vertype v, Vertype dest, int len) {
	visited[v] = 1;
	pathList[v] = G.vertex[v];
	pathLength++;

	if(v == dest) {
		if (pathLength == len) printPath();
		else return;
	}

	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}

	visited[v] = 0;
	pathLength--;
}
```

# â™¾ï¸è®¡ç®—æœº15
## ğŸ’«c-1
```c
#include <stdio.h>

int total(int n) {
	if(n == 1) return 1;
	return total(n-1)+n+1;
}

int main() {
	int n;
	prinft("Enter n: \n");
	scanf("%d", &n);
	int result = total(n);
	printf("result: %d", result);
}
```

## ğŸ’«c-2(å·§ç”¨switch)
> æˆ‘çš„æ–¹æ³•
```c
#include <stdio.h>

typedef struct Data {
	int year;
	int month;
	int day;
}Data;

int has29(int year) {
	if( ((year%4==0) && (year%100 !=0 )) || (year%400 == 0))
		return 29;
	return 28;
}

int solution(Data data) {
	int sum = 0;
	for(int i = 1; i < data.month; i++) {
		if((i==1) && (i==3) && (i==5) && (i==7) && (i==8) && (i==10) && (i==12) &&)
			sum += 31;
		else if( i== 2 ) {
			sum += has29(Data.year);
		} else {
			sum += 30;
		}
	}
	return sum + data.day;
}
```

> æ ‡ç­”å·§ç”¨switch

```c
int solution(Data data) {
	int sum = 0;
	switch(data.month - 1) {
		case 11: num += 30;
		case 10: num += 31;
		case 9: num += 30;
		case 8: num += 31;
		case 7: num += 31;
		case 6: num += 30;
		case 5: num += 31;
		case 4: num += 30;
		case 3: num += 31;
		case 2: num += 28;
		case 1: num += 31;
	}
	return sum;
}
```


## ğŸ’«c-3
```c
#include <stdio.h>

void strcpy(char *s1, char *s2, int k) {
	char *p = s1;
	s1 += k-1;
	while(*s2 != '\0') {
		*s1 = *s2;
		s1++;
		s2++;
	}
	*s1 = '\0';
}

int main() {
	char str1[200], str2[200];
	printf("Enter str1: \n");
	scanf("%s", str1);
	printf("Enter str2: \n");
	scanf("%s", str2);
	int k;
	printf("Enter k: \n");
	scanf("%d", &k);
	
	strcmp(str1, str2, k);
	printf("%s", str1);
}
```

## ğŸ’«æ•°æ®ç»“æ„-1
```c
int solution(LNode *head) {
	// é•¿åº¦ä¸º0æˆ–1, ç›´æ¥è¿”å›æ˜¯
	if (head == NULL && head.next == NULL)
		return 1;
	// é€’å‡: -1, é€’å¢: 1, ç›¸ç­‰: 0
	int flag = 0;
	while(head->next != NULL) {
		int subtract = head->next->data - head->data;
		if(subtract > 0 && flag != -1) {
			flag = 1;
		} else if(subtract < 0 && flag != 1) {
			flag = -1;
		} else if(subtract == 0) {
			
		} else {
			return 0;
		}
		head = head->next;
	}
	return 1;
}
```

## ğŸ’«æ•°æ®ç»“æ„-3(BFSæ›´å¥½?)
```c
#define VERTEX_NUM 100;
int visited[VERTEx_NUM] = {0};
VNode path[VERTEX_NUM];
int pathLen = 0;

void DFS(VNode v, int k, AGraph G) {
	visited[v.data] = 1;
	path[pathLen] = v;
	pathLen++;
	if(pathLen == k) {
		printPath();
		return;
	}
	
	ArcNode *adj = v.firstArc;
	while(adj != NULL) {
		if(visited[adj.adjVex] == 0) {
			DFS(G.vertex[adj.adjVex], k, G);
		}
	}
	
	// å›æº¯
	visited[v.data] = 0;
	pathLen--;
}

int enter(AGraph G,int k, VNode v0) {
	DFS(v0, k, G)
}
```



# â™¾ï¸è®¡ç®—æœº16
## ğŸ’«c-1
```c
int calculation(int n) {
	if(n == 0) {
		return 0;
	} else {
		int begin = n * (n-1) / 2 + 1;
		int tempSum = 1;
		for(int i = 0; i < n; i++) {
			tempSum *= begin;
			begin++;
		}
		
		return tempSum + calculation(n-1);
	}
}

int main() {
	int n;
	scanf("%d", &n);
	printf("n: %d\n", n);
	printf("result: %d", calculation(n));
}
```

## ğŸ’«c-2(æœ‰éš¾åº¦)
> è®¡ç®—æ¯ä¸ªé€‰æ‰‹çš„å¹³å‡åˆ†(æ±‚æ‰€æœ‰åˆ†æ•°çš„å’Œ, å¹¶è®°å½•æœ€å¤§å€¼å’Œæœ€å°å€¼, æœ€åå‡å»)

```c
int main() {
	for(int i = 1; i <= 20; i++) {
		// è®°å½•æœ€å¤§å€¼å’Œæœ€å°å€¼
		int max = 1;
		int min = 10;
		
		double sum = 0;
		double avg = 0;
		for(int j = 0; j<8; j++) {
			int grade;
			scanf("%d", &grade)
			
			sum += grade;
			
			if(grade > max) {
				max = grade;
			}
			if(grade < min) {
				min = grade;
			}
		}
		sum = sum -min - max; // å‡å»æœ€é«˜åˆ†, æœ€ä½åˆ†
		avg = sum / 6; 
	}
}
```

> å®Œæ•´ä»£ç 

```c

double top3[][] = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}}

void isTop3(int code, double grade) {
	for(int i = 0; i < 3; i++) {
		if(grade > top3[i][1]) {
			top3[i][0] = code;
			top3[i][1] = grade;
			return;
		}
	}
}

void printTop3() {
	for(int i = 0; i < 3; i++) {
		// æ³¨æ„%dæ‰“å°doubleæ•°æ®æ—¶, ä¸€å®šè¦å¼ºè½¬!
		printf("ç¼–å·: %d, åˆ†æ•°: %f\n", (int)top3[i][0], top3[i][1]);
	}
}

int main() {
	for(double i = 1; i <= 20; i++) {
		// è®°å½•æœ€å¤§å€¼å’Œæœ€å°å€¼
		int max = 1;
		int min = 10;
		
		double sum = 0;
		double avg = 0;
		for(int j = 0; j<8; j++) {
			int grade;
			scanf("%d", &grade)
			
			sum += grade;
			
			if(grade > max) {
				max = grade;
			}
			if(grade < min) {
				min = grade;
			}
		}
		sum = sum -min - max; // å‡å»æœ€é«˜åˆ†, æœ€ä½åˆ†
		avg = sum / 6; 
		
		isTop3(i, avg);
	}
	
	// å¦‚æœé¢˜ç›®è¦æ±‚å‰ä¸‰åä¹Ÿè¦æ’åº, é‚£å°±åŠ ä¸ªå‡½æ•°å°†top3æ•°ç»„æ’åºå°±è¡Œäº†
	// sortTop3();
	printTop3();
}
```

## ğŸ’«c-3
```c
int findIndex(char *str, char c) {
	int i = 0;
	char *p = str;
	while(*p) {
		if(*p == c) {
			return i;
		}
		i++;
		p++;
	}
	return -1;
}

int main() {
	char str[200];
	char c;
	scanf("%s", str);
	scanf("%c", &c);
	printf("string: %s\n", str);
	printf("char: %c\n", char);
	
	printf("localtion: %d\n", findIndex(str, c));
}
```



## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef int ElementType;

typedef struct DulLinkNode {
	struct DulLinkNode *prior, *next;
	ElementType data;
	int freq;
}DulLinkNode;

void locate(DulLinkNode Dul, ElementType x) {
	DulLinkNode *p = Dul->next;
	while(p != NULL) {
		if(p->data == x) {
			p->freq++;
			break;
		}
		p = p->next;
	}
	
	if(p != NULL && p != locate->next) {
		DulLinkNode *pPre = p->prior;
		while(pPre -> freq < p->freq && pPre != locate) {
			pPre = pPre->prior;
		}
		
		p->prior->next = p->next;
		p->next->prior = p->prior;
		
		p->next = pPre->next;
		p->prior = pPre;
		
		pPre->next->prior = p;
		pPre->next = p;
	}
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM] = {0};
VNode vertexs[VERTEX_NUM];
int vertexsLen = 0;

int DFS(int v, AGraph G) {
	visited[v] = 1;
	print(v);
	
	ArcNode *p = G.adjlist[v].firstArc;
	while(p != NULL) {
		if(visited[p->adjVex] == 0) {
			DFS(p->adjVex, G);
		}
		p = p->nextArc;
	}
}

int solution(AGraph G) {
	int count = 0;
	for(int i = 0; i < G.vexNum; i++) {
		printf("\næ–°çš„è¿é€šåˆ†é‡: ")
		if(visited[i] == 0) {
			DFS(i, G)
		}
		count++;
	}
	
	printf("å…±%dä¸ªè¿é€šåˆ†é‡", count);
}
```


# â™¾ï¸è®¡ç®—æœº17
## ğŸ’«c-1
```c
int main() {
	for(int i = 1; i <= 9 ; i++) {
		for(int j = 1; j <= i; j++) {
			printf("%d*%d=%d ", i, j, i*j);
		}
		printf("\n");
	}
}
```

## ğŸ’«c-2
```c
int arr[200] = {0};
int len = 0;

int getArr(int n) {
	while( (n/10) != 0) {
		int temp = n % 10;
		arr[len] = temp;
		len++;
		
		n = n/10;
	}
}

int isHuiwen() {
	int pre = 0, tail = len - 1;
	while(pre < tail) {
		if(arr[pre] != arr[tail]) {
			return 0;
		}
		pre++;
		tail--;
	}
	return 1;
}

int isWanshu(int n) {
	int sum = 0;
	for(int i = 1; i < n; i++) {
		if( n % i == 0)
			sum += i;
	}
	return sum == n ? 1 : 0;
}

int main() {
	int n;
	scanf("%d", &n);
	getArr(n);
	int huiwenFlag = isHuiwen();
	int wanshuFlag = isWanshu(n);
	
	if(huiwenFlag && wanshuFlag) {
		printf("æ˜¯å›æ–‡å®Œæ•°!");
	} else {
		printf("ä¸æ˜¯å›æ–‡å®Œæ•°!");
	}
}
```

## ğŸ’«c-3
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Student {
	int studentID;
	float score;
	struct Student *next;
}Student;

// å¤´æ’æ³•
void addStudent(Student *head, int code, float score) {
	Student *student = (Student *)malloc(sizeof(Student))
	student->code = code;
	student->score = score;
	
	student->next = head->next;
	head->next = student;
}

int[] account(Student *head) {
	int result[5] = {0};
	Student *p = head->next;
	while(p != NULL) {
		if(p->score < 60) {
			result[0]++;
		} else if(p->score >= 60 && p->score < 70) {
			result[1]++;
		} else if(p->score >= 70 && p->score < 80) {
			result[2]++;
		} else if(p->score >= 80 && p->score < 90) {
			result[3]++;
		} else {
			result[4]++;
		}
		p = p->next;
	}
	return result;
}

int main() {
	// åˆ›å»ºå¤´ç»“ç‚¹
	Student *head = (Student *)malloc(sizeof(Student))
	int code;
	float score;
	
	while(1) {
		scanf("%d", &code);
		if(code != 0) {
			printf("code: %d\n", code);
		} else {
			break;
		}
		scanf("%f", &score);
		printf("score: %f\n\n", score);
		
		addStudent(head, code, score);
	}
	
	int result[] = account(head);
	printf("60ä»¥ä¸‹: %d\n", result[0]);
	printf("60~70: %d\n", result[1]);
	printf("70~80: %d\n", result[2]);
	printf("80~90: %d\n", result[3]);
	printf("90~100: %d\n", result[4]);
}
```

## ğŸ’«æ•°æ®ç»“æ„-1
```c
void solution(LNode *list) {
	LNode *slow = list
	// é“¾è¡¨é•¿åº¦ä¸º0, ç›´æ¥ç»“æŸ
	while(slow == NULL) {
		return;
	}
	LNOde *fast = list->next;
	
	while(fast != NULL) {
		while(fast != NULL && fast->data == slow->data) {
			fast=fast->next;
		}
		
		slow->next = fast;
		slow=slow->next;
		if(fast != NULL) {
			fast=fast->next;
		}
	}
}
```

## ğŸ’«æ•°æ®ç»“æ„-3
```c
typedef int VertexType;

typedef struct ArcNode {
	int adjVex;
	struct ArcNode *nextArc;
}ArcNode;

typedef struct VNode {
	VertexType data;
	ArcNode *firstArc;
}VNode;

#define VERTEX_NUM 10;

VNode[VERTEX_NUM] solution(VNode list[VERTEX_NUM]) {
	VNode result[VERTEX_NUM];
	// å°†listå¤åˆ¶ç»™result
	copy(result, list);
	// æ¸…ç©ºresultä¸­VNodeçš„firstArcç»“ç‚¹
	emptyFirstArc(result);
	
	for(int i = 0; i < VERTEX_NUM; i++) {
		ArcNode *p = list[i].firstArc;
		while(p != NULL) {
			ArcNode *newArc = (ArcNode *)malloc(sizeof(ArcNode))
			newArc->adjVex = i;
			newArc->next = result[p->ajdVex].firstArc;
			result[p->ajdVex].firstArc = newArc;
		}
	}
	
	return result;
}
```



# â™¾ï¸è®¡ç®—æœº18
## ğŸ’«c-1
```c
#include <stdio.h>  
  
int result[6][3];  
int resultLen[6] = {0};  
  
void insertResult(int n) {  
    int flag = n % 2;  
    if (flag == 0) {  
        for (int i = 1; i <= 5; i += 2) {  
            int row;  
            if (resultLen[i] != 3) {  
                row = i;  
                result[i][resultLen[i]] = n;  
                resultLen[i]++;  
                break;  
            }  
        }  
    } else {  
        for (int i = 0; i <= 4; i += 2) {  
            int row;  
            if (resultLen[i] != 3) {  
                row = i;  
                result[i][resultLen[i]] = n;  
                resultLen[i]++;  
                break;  
            }  
        }  
    }  
}  
  
void printResult() {  
    for (int i = 0; i < 6; i++) {  
        printf("%d: ", i + 1);  
        int len = resultLen[i];  
        if (len > 0) {  
            for (int j = 0; j < len; ++j) {  
                printf("%d ", result[i][j]);  
            }  
        }  
        printf("\n");  
    }  
}  
  
void solution(int arr[3][3]) {  
    for (int i = 0; i < 3; i++) {  
        for (int j = 0; j < 3; j++) {  
            insertResult(arr[i][j]);  
        }  
    }  
}  
  
int main() {  
    int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};  
    solution(arr);  
    printResult();  
}
```

## ğŸ’«c-2
```c
int solution(char *string) {
	char maxText[3000];
	char max = 0;
	char minText[3000];
	int min = 3000;
	char *pre = string;
	char *tail = string;
	
	while(tail != '#') {
		// å…ˆè®©tailæ‰¾åˆ°ä¸€ä¸ªéç©ºæ ¼çš„å­—ç¬¦
		while(tail != '#' && tail == ' ') {
			tail++;
		}
		pre = tail;
		// æ‰¾åˆ°ä¸‹ä¸€ä¸ªç©ºæ ¼
		while(tail != '#' && tail != ' ') {
			tail++;
		}
		// æ¯”è¾ƒé•¿åº¦
		if(tail - pre > max) {
			max = tail - pre;
			copy(maxText);
		}
				// æ¯”è¾ƒé•¿åº¦
		if(tail - pre < min) {
			min = tail - pre;
			copy(minText);
		}
	}
	
	printf("min: %s \n max: %s", minText, maxText);
}
```


## ğŸ’«c-3
```c
typedef struct Salary {
	char id[10];
	char name[20];
	float wage;
	struct Salary *next;
}Salary;

void printOneSalary(Salary *salary) {
	printf("id: %s, name: %s, wage: %f\n", salary->id, salary->name, salary->wage);
}

// æ‰“å°ç»“ç‚¹, é¡ºä¾¿æŠŠå‘˜å·¥äººæ•°è¿”å›
int printAllSalary(Salary *salary) {
	int len = 0;
	Salary *p = salary
	while(p != NULL) {
		len++;
		printOneSalary(p);
		p = p->next;
	}
	return len;
}

void insertOne(Salary *head, Salary *salary) {
	Salary *p = head;
	while(p -> next != NULL && p->next->data < salary->data) {
		p = p->next;
	}
	salary->next = p->next;
	p->next= salary;
}

Salary* sortSalary(Salary *salary) {
	Salary *head = (Salary *)malloc(sizeof(Salary));
	Salary *p = salary;
	while( p != NULL) {
		insertOne(head, p);
		p = p->next;
	}
	return head->next;
}

int getMiddle(Salary *salary, int len) {
	Salary *p = salary
	for(int i = 1; i < (len/2); i++) {
		p = p->next;
	}
	if(len % 2 == 0) {
		return (p->data + p->next->data) / 2;
	} else {
		return p->data;
	}
}

int solution(Salary *salary) {
	// æ‰“å°æ‰€æœ‰å‘˜å·¥çš„å·¥èµ„ä¿¡æ¯
	int len = printALlSalary(Salary *salary);
	// è·å–ä¸­ä½æ•°
	Salary *sorted = sortSalary(salary);
	int middle = getMiddle(sorted, len);
}
```

## ğŸ’«æ•°æ®ç»“æ„-1
```c
int solution(char arr[], int len) {
	int count = 0;
	for(int i = 0; i < len; i++) {
		if(arr[i] == 'D') {
			count--;
		} else {
			count++;
		}
		
		if(count < 0){
			return 0;
		}
	}
	if(count > 0) {
		return 0;
	}
	return 1;
}
```



## ğŸ’«æ•°æ®ç»“æ„-3
```c
#define MAX_VNODE_NUM 10

typedef struct ArcNode {
	int vIndex;
	struct ArcNode *next;
}ArcNode;

#define int EleType

typedef struct VNode {
	EleType data;
	ArcNode *firstArc;
}VNode;

typedef strcut AGraph {
	VNode[MAX_VNODE_NUM] nodes;
	int vexNum;
	int arcNum;
}AGraph;


int visited[MAX_VNODE_NUM] = {0};
VNode path[MAX_VNODE_NUM];
int length = 0;
int flag = 0;

void DFS(AGraph G, int v, VNode end, int k) {
	visited[v] = 1;
	path[len] = G.nodes[v]
	length++;
	
	if(length == k && v == end) {
		printPath();
		flag = 1;
		return;
	}
	
	ArcNode *p = G.nodes[v].firstArc;
	while( p != NULL) {
		if(visited[p.vIndex] == 0 && length < k) {
			DFS(G, p.vIndex, end, k);
		}
		p = p->next;
	}
	
	visited[v] = 0;
	length--;
}

int solution(AGraph G, int v, int end, int k) {
	DFS(G, v, end, k);
	return flag;
}
```


# â™¾ï¸è®¡ç®—æœº19
## ğŸ’«c-1
```c
int judge(int n) {
	int square = n * n;
	while( n > 0) {
		if(n%10 != square%10) {
			return 0;
		}
		
		n /= 10;
		square /= 10
	}
	return 1;
}

int main(){
	for(int i = 1; i <= 1000; i++) {
		if(judge(i)) {
			printf("%d ", i);
		}
	}
}
```


## ğŸ’«c-2
```c
int judgeM(int a[N][N]) {
	for(int i = 0; i<N; i++) {
		for(int j = 0; j<i; j++) {
			if(arr[i][j]!=0){
				return 0;
			}
		}
	}
	return 1;
}
```

## ğŸ’«c-3

> ä½¿ç”¨æ’åº, å°†ç›¸åŒçš„pidç›¸é‚»!
```c
typedef struct Consume {
	int id;
	unsigned pid;
	char p[100];
	float cost;
}Consume;

// æ ¹æ®pidå°†recordè¿›è¡Œæ’åº
void sortRecords(struct Consume record[N]) {
	for(int i = 0; i < N-1; i++) {
		for(int j = 0; j < N - 1 - i; j++) {
			if(record[j].pid > record[j+1].pid) {
				struct temp = record[j];
				record[j] = record[j+1];
				record[j+1] = temp;
			}
		}
	}
}

void maxCost(struct Consume record[N]) {
	sortRecords(record);
	
	int maxPid = 0;
	char maxName[100];
	float maxSum = 0;
	
	int curPid = -1;
	char curName[100];
	float curSum = 0;
	for(int i = 0; i<N; i++) {
		if(record[i].pid != curPid) {
			curPid = record[i].pid;
			curName = record[i].p;
			curSum = record[i].cost;
		} else {
			curSum += record[i].cost;
			if(curSum > maxSum) {
				maxPid = record[i].pid;
				maxCurName = record[i].p;
				maxSum = curSum;
			}
		}
	}
	
	printf();
}
```


## ğŸ’«æ•°æ®ç»“æ„-1(è¾ƒéš¾)
```c
int solution(LNode *head) {
	int count = 0;
	
	if(head == NULL || head->next == NULL) return 0;

	LNode *slow = head;
	LNode *fast = head->next;
	
	int curFlag = fast->data - slow->data > 0 ? 1 : 0;
	while(fast->next != NULL) {		
		if( ((fast->next->data - fast->data) > 0 && !curFlag ) { é€’å‡åºåˆ—, å³å°†é€’å¢
			count++;
			curFlag = 1;
			slow = fast;
			fast = fast->next;
		} else if ( ((fast->next->data - fast->data) < 0 && curFlag ) { é€’å¢åºåˆ—, å³å°†é€’å‡
			count++;
			curFlag = 0
			slow = fast;
			fast = fast->next;
		} else {
			fast = fast->next;
		}
	}
	
	if(slow != fast) {
		count++;
	}
	
	return count;
}
```

## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_MAX] = {0};
int count = 0;

void DFS(int v, ALGraph G) {
	visited[v] = 1;
	count++;
	
	ArcNode *p = G.vertices[v].firstArc;
	while(p != NULL) {
		if(visited[p.adjVex] != 1) {
			DFS(p.adjVex, G)
		}
		p = p->next;
	}
}

int solution(ALGraph G) {
	DFS(0, G);

	if(count != G.vertexNum) return 0;
	else return 1;
}
```


