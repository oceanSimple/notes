# â™¾ï¸æ€»ç»“
## ğŸ’«ç»“æ„ä½“
### ListNode
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;
```

### é‚»æ¥è¡¨å›¾
```c
#define MAX_VERTEX_NUM 100  
  
typedef struct ArcNode {  
    int adjVex; // ç»“ç‚¹æ•°ç»„çš„ç´¢å¼•, ç”¨æ¥æŸ¥æ‰¾å…·ä½“çš„ç»“ç‚¹ä¿¡æ¯  
    struct ArcNode *nextArc;  
    int weight; // æƒé‡  
} ArcNode;  
  
typedef int VertexType;  
  
typedef struct VNode {  
    VertexType data;  
    ArcNode *firstArc; // ç¬¬ä¸€ä¸ªé‚»æ¥ç»“ç‚¹  
} VNode, AdjList[MAX_VERTEX_NUM];  
  
typedef struct {  
    AdjList vertices; // æ‰€æœ‰ç»“ç‚¹  
    int vexNum; // ç»“ç‚¹æ•°, ä¹Ÿå³verticesæ•°ç»„é•¿åº¦  
    int arcNum; // æ€»çš„å¼§æ•°  
    int kind; // å›¾çš„ç±»å‹  
} ALGraph;
```

## ğŸ’«æ–‡ä»¶å¤„ç†
### æ‰“å¼€æ–‡ä»¶
```c
	FILE *fp = fopen("1.txt", "r");
	if (fp == NULL) {
		perror("file open error");
		exit(1);
	}
	fclose(fp);
```

### è¯»å–ä¸€ä¸ªå­—ç¬¦
```c
	char buf;
	while(fscanf(fp, "%c%, &buf) > 0) {
		printf("%c", buf);
	}
```

### å†™æ–‡ä»¶
```c
void writeData(char dataList[][COLUMN_MAX], int dataLen) {
	FILE *fp = fopen("file2.txt", "w");
	if (fp != NULL) {
		for(int i = 0; i < dataLen; i++){
			fprintf(fp, "%s ", dataList[i]);
		}
	}
	fclose(fp);
}
```

## ğŸ’«å­—ç¬¦ä¸²æ“ä½œå‡½æ•°
- string.håŒ…
- æ¯”è¾ƒ: strcmp(s1, s2) : s1 > s2?
- å¤åˆ¶: strcpy(s1, s2) : s2èµ‹å€¼ç»™s1


## ğŸ’«å…¶ä»–
### malloce
```c
LNode *node = (LNode*)malloc(sizeof(LNode));
```

### strLen
```c
int strLen(char *str) {
	char *p = str;
	int strLen = 0;
	while(*p != '\0') {
		strLen++;
		p++;
	}
	return strLen;
}
```

### æŒ‡é’ˆéå†å­—ç¬¦ä¸²
```c
char *stuff(char *str1, char *str2, int i, int j) {
	int instance = j - 1 + 1;
	int str2Len = strlen(str2);
	if (distance != str2Len) {
		return 0;
	}
	char *p = str2;
	i = i-1; // å¯¹é½æ•°ç»„ä¸‹æ ‡
	while(i<=j-1) {
		*(str + i) = *p
		i++;
		p++;
	}
	return 1;
}
```

### å­—ç¬¦ä¸²å€’åºéå†

```c
int printUpper(char *str) {
	// å°†pæŒ‡é’ˆç§»åˆ°å­—ç¬¦ä¸²çš„æœ€å
	char *p = str;
	while((*p) != '\0') p++;
	
	// å€’å™éå†
	while(p >= str) {
		if(*p >= 'A' && *p <= 'Z')
			printf("%c", *p);
			
		p--;
	}
}
```


### ä»æ§åˆ¶å°è¯»å–è¾“å…¥
```c
int main(){
	int arr[100] = {0};
	int arrLen = 0;
	int temp_data;
	scanf("%d", &temp_data);
	while(temp_data != 0) {
		arr[arrLen] = temp_data;
		arrLen++;
		scanf("%d", &temp_data);
	}
	solution(arr, arrLen);
}
```


# â™¾ï¸è®¡ç®—æœº10
## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;
void printMin(LNode *head) {
	int min = head -> data;
	min = head->next->data < min ? head->next->data : min;
	min = head->next->next->data < min ? head->next->next->data : min;
	printf("%d", min);
}
int solution(LNode *head) {
	// ä¸´æ—¶æŒ‡é’ˆ
	LNode *p = head -> next;
	while ((p != NULL) && (p->next != NULL) && (p->next->next != NULL)) {
		int sum = p->next->data + p->next->next->data;
		if (sum != p->data) {
			printMin(p);
			return 0;
		}
		p = p->next;
	}
	printf("%d", head->next->data);
	return 1;
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[MAX_VERTEX_NUM] = {0};

void BFS(ALGraph G) {
	Stack s = InitStack();
	for (int i=0; i<G.vexNum; i++) {
		if(visited[i] == 0) {
			Push(s, G.vertices[i]);
			while(!IsEmpty(s)) { // å¦‚æœæ ˆéç©º, åˆ™å¾ªç¯
				VNode *temp = Pop(s);
				print("%d ", temp->data);
				visited[temp->data] = 1;
				
				ArcNode *p = temp -> firstArc;
				while (p != NULL) {
					if(visited[p->adjVex] == 0) {
						Push(s, G.vertices[p->adjVex])
					}
					p = p->nextArc;
				}
			}
		}
	}
}
```



# â™¾ï¸è®¡ç®—æœº11

## ğŸ’«c-1
```c
#include <stdio.h>

int main(){
	FILE *fp = fopen("1.txt", "r");
	if (fp == NULL) {
		perror("file open error");
		exit(1);
	}
	char buf;
	int count = 0;
	
	while(fscanf(fp, "%c%, &buf) > 0) {
		count++;
		printf("%c", buf);
		if(buf == '\n') {
			count = 0;
			continue;
		}
		if (count == 30) {
			printf("\n");
			count = 0;
		}
	}
	
	fclose(fp);
}
```

## ğŸ’«c-2
```c
#include <stdio.h>
#include <string.h>

int strLen(char *str) {
	char *p = str;
	int strLen = 0;
	while(*p != '\0') {
		strLen++;
		p++;
	}
	return strLen;
}

char *stuff(char *str1, char *str2, int i, int j) {
	int instance = j - 1 + 1;
	int str2Len = strlen(str2);
	if (distance != str2Len) {
		return 0;
	}
	char *p = str2;
	i = i-1; // å¯¹é½æ•°ç»„ä¸‹æ ‡
	while(i<=j-1) {
		*(str + i) = *p
		i++;
		p++;
	}
	return 1;
}
```

## ğŸ’«c-3
```c
#include <stdio.h>

#define ROW_NUM 3;
#define COLUMN_NUM 3;

int findRowMax(int arr[ROW_NUM][COLUMN_NUM],int i) {
	int max = 0;
	for(int j = 0; j< COLUMN_NUM; j++) {
		max = arr[i][j] > arr[i][max] ? arr[i][j] : arr[i][max];
	}
	return max;
}

int findRowMax(int arr[ROW_NUM][COLUMN_NUM],int row, int column) {
	for(int i = 0; i < ROW_NUM; i++) {
		if(arr[i][column] < arr[row][column])
			return 0;
	}
	return 1;
}

int findAnNode(int arr[ROW_NUM][COLUMN_NUM]) {
	// éå†è¡Œ
	for(int i = 0; i< ROW_NUM; i++) {
		int index = findRowMax(arr, i); // æ‰¾åˆ°è¡Œæœ€å¤§å€¼çš„åˆ—ä¸‹æ ‡ç´¢å¼•
		int flag = judgeIsCoulumnMin(arr, i, index); // åˆ¤æ–­æ˜¯å¦ä¸ºåˆ—æœ€å°
		if(flag == 1) {
			print("%d", arr[i][index]);
			return 1;
		}
	}
	return 0;
}
```

## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;

void insertIntoList(LNode *head, int data) {
	LNode *node = (LNode*)malloc(sizeof(LNode));
	node -> data = data;
	node -> next = NULL;
	
	LNode *slow = head;
	LNode *fast = head->next;
	while(fast == NULL || fast->data < data) {
		slow = slow->next;
		fast = fast->next;
	}
	
	slow->next = node;
	node->next = fast;
}

void printList(LNode *head) {
	LNode *index = head->next;
	while(index != NULL) {
		printf("%d\n", index->data)
		index = index->next
	}
}

LNode* solution(int arr[], int arrLen) {
	LNode *head = (LNode*)malloc(sizeof(LNode));
	head -> next = NULL;
	
	for(int i = 0; i < arrLen; i++){
		insertIntoList(head, arr[i]);
	}
	
	printList(head);
}

int main(){
	int arr[100] = {0};
	int arrLen = 0;
	int temp_data;
	scanf("%d", &temp_data);
	while(temp_data != 0) {
		arr[arrLen] = temp_data;
		arrLen++;
		scanf("%d", &temp_data);
	}
	solution(arr, arrLen);
}
```




## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {9};

void Solution(ALGragh G) {
	for(int i = 0; i < VERTEX_NUM_MAX; i++) {
		if (visited[i] == 0) {
			print("%d\n", G.vertex[i].data);
			DFS(G, G.vertex[i]);
		}
	}
}

void DFS(ALGragh G, Vertex v) {
	visit[v] = 1;
	AdjVertex *adj = v.firstAdj; // ç¬¬ä¸€ä¸ªé‚»æ¥ç»“ç‚¹
	while(NULL != adj) {
		if (visited[adj.index] == 0) {
			DFS(G, G.vertex[adj.index]);
		}
		adj = adj.next;
	}
}
```

# â™¾ï¸è®¡ç®—æœº13
## ğŸ’«c-1
```c
int longf(int n, int m) {
	if( m == 0 || m > n){
		return 0;
	}
	if( m == 1 || m == n){
		return 1;
	}
	return m + longf(n-1, m) - longf(n-1, m-1);
}
```

## ğŸ’«c-2
```c
#define ROW_LEN 3;
#define COLUMN_LEN 3;

int judge(int arr[][]){
	// æ£€æŸ¥è¡Œ
	for(int i = 0;i < ROW_LEN; i++){
		int sum = 0;
		for(int j=0; j< COLUMN_LEN; j++){
			sum+=arr[i][j];
		}
		if(sum != 15)
			return 0;
	}
	// æ£€æŸ¥åˆ—
	for(int i = 0;i < COLUMN_LEN; i++){
		int sum = 0;
		for(int j=0; j< ROW_LEN; j++){
			sum+=arr[j][i];
		}
		if(sum != 15)
			return 0;
	}
	// æ£€æŸ¥å¯¹è§’çº¿
	int leftLine = arr[1][1] + arr[2][2] + arr[3][3];
	int rightLine = arr[1][3] + arr[2][2] + arr[3][1];
	if((leftLine != 15) || (rightLine != 15))
		return 0;
		
	return 1;
}
```

## ğŸ’«c-3(è¯»å†™æ–‡ä»¶, å­—ç¬¦ä¸²æ’åº)
```c
#include <stdio.h>
#include <string.h>

#define ROW_MAX 50;
#define COLUMN_MAX 50;

int main() {
	char dataList[ROW_MAX][COLUMN_MAX];
	int dataLen = 0;
	readData(dataList, &dataLen);
	sortData(dataList, dataLen);
	writeData(dataList, dataLen);
}

void readData(char dataList[ROW_MAX][COLUMN_MAX], int *dataLen) {
	FILE *fp = fopen("file1.txt", "r");
	if (p != NULL) {
		while((fscanf(fp, "%s", dataList[*dataLen])) > 0) {
			*dataLen+=1;
		}
	}
	fclose(fp);
}

// å†’æ³¡æ’åº
void sortData(char dataList[][COLUMN_MAX], int dataLen) {
	for(int i = 0; i < dataLen; i++) {
		char temp[COLUMN_MAx];
		for(int j = 0; j < dataLen-1-i; j++) {
			if(strcmp(dataList[j], dataList[j+1]) > 0) {
				strcpy(temp, dataLit[j]);
				strcpy(dataList[j], dataList[j+1]);
				strcpy(dataList[j+1], temp);
			}
		}
	}
}

void writeData(char dataList[][COLUMN_MAX], int dataLen) {
	FILE *fp = fopen("file2.txt", "w");
	if (fp != NULL) {
		for(int i = 0; i < dataLen; i++){
			fprintf(fp, "%s ", dataList[i]);
		}
	}
	fclose(fp);
}
```


## ğŸ’«æ•°æ®ç»“æ„-1
```c
typedef struct ListNode {
	int data;
	struct ListNode *next;
}LNode;

// 0: åˆ é™¤å¤±è´¥, 1: åˆ é™¤æˆåŠŸ
int solution(LNode *la, int i, int len) {
	LNode *slow = la;
	LNode *fast = la;
	// slowå’Œfastç›¸èšlenä¸ªèº«ä½
	for(int count = 0; count < len; count++) {
		if(fast == NULL)
			return 0; // é“¾è¡¨é•¿åº¦ä¸å¤Ÿ, åˆ é™¤å¤±è´¥
			
		fast = fast->next;
	}
	// ä½¿slowæŒ‡å‘ç¬¬iä¸ªå…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ , fastæŒ‡å‘ç¬¬i+len-1ä¸ªå…ƒç´ 
	for(int index = 1; index < i; index++) {
		slow = slow->next;
		fast = fast->next;
	}
	slow->next = fast->next;
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {0};
// æ ¼å¼åŒ–visitedæ•°ç»„
void EmptyVisited(int length) {
	for(int i = 0; i < length; i++) {
		visited[i] = 0;
	}
}
// åˆ¤æ–­visitedæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯å¦éƒ½ä¸º1
void JudgeIncludeAllVertex(int length) {
	for(int i = 0; i < length; i++) {
		if(visited[i] == 0) return 0;
	}
	return 1;
}
// DFSéå†
void DFS(ALGraph G, VertexType v) {
	visited[v] = 1;
	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}
}

int HasRoot(ALGraph G) {
	int length = G.verNum;
	// éå†æ‰€æœ‰çš„ç»“ç‚¹
	for(int i = 0; i < G.vexNum; i++) {
		EmptyVisited(length); // æ¸…ç©ºvisitedæ•°ç»„
		DFS(G, i);
		int flag = JudgeIncludeAllVertex(length);
		if (flag == 1) return 1;
		else print("%d\n", G.vertex[i].data);
	}
	return 0;
}
```

# â™¾ï¸è®¡ç®—æœº14
## ğŸ’«c-1
```c
#include <stdio.h>

int main() {
	int i = 0;
	while(1) {
		if( ((i%5)==1) && ((i%6)==5) && ((i%7)==4) && ((i%11)==10))
			break;
		i++;
	}
	printf("%d", i);
}
```

## ğŸ’«c-2
```c
#include <stdio.h>

int main() {
	char str[MAX_LEN];
	int big = 0;
	int small = 0;
	gets(str);
	count(str, &big, &small);
	printUpper(str);
}

int count(char *str, int *bigNumber, int *smallNumber) {
	char *p = str;
	while(p != '\0') {
		if(*p >= 'A' && *p <= 'Z')
			(*bigNumber)++;
		if(*p >= 'a' && *p <= 'z')
			(*smallNumber)++;
		p++;
	}
}

int printUpper(char *str) {
	// å°†pæŒ‡é’ˆç§»åˆ°å­—ç¬¦ä¸²çš„æœ€å
	char *p = str;
	while((*p) != '\0') p++;
	
	// å€’å™éå†
	while(p >= str) {
		if(*p >= 'A' && *p <= 'Z')
			printf("%c", *p);
			
		p--;
	}
}
```


## ğŸ’«æ•°æ®ç»“æ„-1
```c
void solution(int arr[], int len) {
	int left = 0;
	int right = len-1;
	while(left < right) {
		while( (left<right) && arr[left]<=0 )
			left++;
		while((left<right) && arr[right]>=0)
			right--;
			
		int temp = arr[left];
		arr[left] = arr[right];
		arr[right] = temp;
		
		left++;
		right--;
	}
}
```


## ğŸ’«æ•°æ®ç»“æ„-3
```c
int visited[VERTEX_NUM_MAX] = {0};
int pathList[VERTEX_NUM_MAX] = {0};
int pathLength = 0;

void DFS(ALGraph G, Vertype v, Vertype dest, int len) {
	visited[v] = 1;
	pathList[v] = G.vertex[v];
	pathLength++;

	if(v == dest) {
		if (pathLength == len) printPath();
		else return;
	}

	ArcNode *adj = G.vertex[v].firstArc;
	while(NULL != adj) {
		VertexType temp = adj.adjVex;
		if(visited[temp] == 0) {
			DFS(G, temp);
		}
		adj = adj.next;
	}

	visited[v] = 0;
	pathLength--;
}
```
