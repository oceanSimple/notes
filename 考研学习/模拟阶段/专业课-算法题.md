# â™¾ï¸é“¾è¡¨




# â™¾ï¸äºŒå‰æ ‘
## ğŸ’«åŸºç¡€
### æ±‚äºŒå‰æ ‘çš„é«˜åº¦
```c
int getHeight(BTree *T) {
	if(T == NULL)
		return 0;

	int lHeight = getHeight(T->lchild);
	int rHeight = getHeight(T->rchild);

	return lHeight > rHeight ? lHeight+1 : rHeight+1;
}
```

### å±‚åºéå†
> è¯´æ˜: ä¹‹æ‰€ä»¥ä½¿ç”¨Qlenå’ŒnextLayerLen, æ˜¯å› ä¸ºCè¯­è¨€è²Œä¼¼æ²¡æœ‰len(Q)çš„å‡½æ•°, å› æ­¤åªèƒ½è‡ªå·±å®ç°äº†
```c
void layerOrder(BTree *T) {
	int layer = 0;
	
	if(T == NULL) return;
	
	Queue Q;
	initQueue(Q);
	int Qlen = 0; // è®°å½•å½“å‰å±‚çš„ç»“ç‚¹æ•°é‡
	
	enQueue(T);
	layer++;
	Qlen++;
	
	while(Qlen > 0) {
		int nextLayerLen = 0;
		for(int i = 1; i<= Qlen; i++) {
			BTree *tmp;
			deQueue(Q, tmp);
			// å¤„ç†ç»“ç‚¹...
			
			if(tmp->lchild != NULL) {
				enQueue(Q, tmp->lchild);
				nextLayerLen++;
			}
			if(tmp->rchild != NULL) {
				enQueue(Q, tmp->rchild);
				nextLayerLen++;
			}
		}
		Qlen = nextLayerLen;
		layer++;
	}
}
```

### åˆ é™¤äºŒå‰æ’åºæ ‘ä¸­çš„ç»“ç‚¹
```c
void delete(BTree *T) {
	// å¦‚æœæ²¡æœ‰å·¦å³å­æ ‘, ç›´æ¥NULL
	if(T->lchild == NULL && T->rchild == NULL) {
		T = NULL;
		return;
	}
	
	// å¦‚æœåªæœ‰å·¦æˆ–å³å­æ ‘, ç›´æ¥ä»£æ›¿Tå³å¯
	if(T->lchild == NULL ** T->rchild != NULL) {
		T = T->rchild;
		return;
	}
	if(T->lchild != NULL ** T->rchild == NULL) {
		T = T->lchild;
		return;
	}
	
	// å¦‚æœå«æœ‰å·¦å³å­æ ‘
	// æ‰¾åˆ°å·¦å­æ ‘ä¸­çš„æœ€å¤§å€¼
	BTree *tmp = T->lchild;
	while(tmp->rchild != NULL)
		tmp = tmp->rchild;
	// å°†Tçš„å³å­æ ‘æŒ‚è½½åˆ°tmpçš„å³å­æ ‘
	tmp->rchild = T->rchild;
	// åˆ é™¤Tç»“ç‚¹
	T = T->lchild;
}
```


### æ„å»ºäºŒå‰æ’åºæ ‘
```c
void insert(BTree *T, EleType x) {
	// å¦‚æœT==NULL, ç›´æ¥åˆ›å»ºæ–°èŠ‚ç‚¹
	if(T == NULL) {
		BTree *tmp = (BTree *)malloc(sizeof(BTree));
		tmp -> lchild = NULL;
		tmp -> rchild = NULL;
		T = tmp;
		return;
	}
	
	if(x > T->data) {
		insert(T->rchild, x);
		return;
	}
	
	if(x < T->data) {
		insert(T->lchild, x);
		return;
	}
}
```




## ğŸ’«åŸºç¡€é¢˜
### 6. æŸ¥æ‰¾äºŒå‰æ ‘ä¸­å€¼ä¸ºxçš„ç»“ç‚¹
> é€’å½’ç®—æ³•è¿”å›

```c
BTree *seekNode(BTree *Tree, EleType x) {
	if(Tree == NULL) return NULL;
	
	if(Tree->data = x)
		return Tree;
		
	BTree lResult = seekNode(Tree->lchild, x);
	if(lResult != NULL)
		return lResult;
	
	return seekNode(Tree->rchild, x);
}
```

> ä¹Ÿå¯ä»¥ä½¿ç”¨å…¨å±€å˜é‡è®°å½•æŸ¥æ‰¾çš„å€¼, è¿™æ ·å¯ä»¥ç®€åŒ–ä»£ç 

### 9. äº¤æ¢äºŒå‰æ ‘çš„å·¦å³å­æ ‘
```c
void switch(BTree *T) {
	if(T == NULL)	return;
	
	BTree *tmp = T->lchild;
	T->lchild = T->rchild;
	T->rchild = tmp;
	
	switch(T->lchild);
	switch(T->rchild);
}
```

### 10. åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ç›¸ä¼¼
```c
int flag = 1;

void similar(BTree *A, BTree *B) {
	if(A == NULL && B == NULL) {
		return;
	}

	if(A == NULL && B != NULL) {
		flag = 0;
		return;
	}
	if(A != NULL && B == NULL) {
		flag = 0;
		return;
	}
	
	similar(A->lchild, B->lchild);
	similar(A->rchild, B->rchild);
}
```

### â€»12. ç®—æ•°è¡¨è¾¾å¼æ ‘
```c
int caculate(char c, int a, int b) {
	switch(c) {
		case '+': return a+b;
		case '-': return a-b;
		case '*': return a*b;
		case '/': return a/b;
	}
}

int solution(BTree *T) {
	if(T->data == NULL)
		return 0;

	if(T->data >= '0' && T->data <= '9')
		return T->data - '0';
		
	
	return caculation(T->data, solution(T->lchild), solution(T->rchild));
}
```

### â€»13. åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘
> å±‚åºéå†çš„å˜ç§
```c
void layerOrder(BTree *T) {
	if(T == NULL) return;
	
	Queue Q;
	initQueue(Q);
	
	enQueue(T);
	Qlen++;
	
	while(Qlen > 0) {
		int nextLayerLen = 0;
		for(int i = 1; i<= Qlen; i++) {
			BTree *tmp;
			deQueue(Q, tmp);
			
			if(tmp == NULL) break;
			
			enQueue(Q, T->lchild);
			enQueue(Q, T->rchild);
		}
		Qlen = nextLayerLen;
	}
	
	// å¦‚æœå‰©ä½™é˜Ÿåˆ—ä¸­å­˜åœ¨éNULLçš„ç»“ç‚¹, è¯´æ˜ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘!
	while(!IsEmpty(Q)) {
		BTree *tmp;
		deQueue(Q, tmp);
		if(tmp != NULL)
			return 0;
	}
	
	return 1;
}
```

### â€»19
é¢˜ç›®: å°†ä¸€é¢—äºŒå‰æ’åºæ ‘t, åˆ†æˆä¸¤é¢—æ ‘t1, t2. t1ä¸­æ‰€æœ‰ç»“ç‚¹å°äºx, t2ä¸­æ‰€æœ‰èŠ‚ç‚¹å¤§äºx
> - å…ˆåºéå†
> - æ ¹èŠ‚ç‚¹ > x, æ ¹èŠ‚ç‚¹ + rchild åŠ å…¥åˆ°t2, é€’å½’å·¦å­æ ‘
> - æ ¹èŠ‚ç‚¹ = x, lchild åŠ å…¥ t1, rchildåŠ å…¥t2, return
> - æ ¹èŠ‚ç‚¹ < x, æ ¹èŠ‚ç‚¹ + lchild åŠ å…¥åˆ°t1, é€’å½’å³å­æ ‘

```c
void insert(BTree *root, BTree *pNode) {
	if(root == NULL)
		root = pNode;
	else if(pNode->data > root->data)
		insert(root->rchild, pNode);
	else if(pNode->data < root->data)
		insert(root->lchild, pNode);
}

void preOrder(BTree *root, BTree *t1, BTree *t2, int x) {
	if(root == NULL)
		return;
		
	if(root->data > x) {
		preOrder(root->lchild, t1, t2, x);
		T->lchild = NULL;
		insert(t2, T)
	} else if(root->data == x) {
		insert(t1, root->lchild);
		insert(t2, root->rchild);
	} else if(root->data < x) {
		preOrder(root->rchild, t1, t2, x);
		T->rchild = NULL;
		insert(t1, T);
	}

}
```

### â€»20
é¢˜ç›®: åˆ é™¤æ‰€æœ‰å°äºxçš„ç»“ç‚¹
> - å…ˆåºéå†
> - root > x, é€’å½’lchild
> - root = x, root = rchild
> - root < x, lchild = NULL, é€’å½’rchild

```c
// åˆ é™¤å¹¶é‡Šæ”¾æ ‘
void deleteBTree(BTree *T) {
	if(T == NULL) return;
	
	deleteBTree(T->lchild);
	deleteBTree(T->rchild);
	
	T->lchild = NULL;
	T->rchild = NULL;
	free(T);
	T = NULL;
}

void preOrder(BTree *T, int x) {
	if(T == NULL) return;
	
	if(T->data > x) {
		preOrder(T->lchild, x);
	} 
	else if(T->data == x) {
		delete(T->lchild);
		T->lchild = NULL;
	}
	else {
		deleteBTree(T->lchild);
		BTree *temp = T;
		T = T->rchild;
		preOrder(T, x);
		free(temp);
	}
}
```

### 21. è®¡ç®—æ¯ä¸ªç»“ç‚¹çš„å¹³è¡¡å› å­(æ·±åº¦å˜ç§)
> - è€ƒç‚¹åœ¨æ±‚æ·±åº¦
> - æ±‚å‡ºrootçš„å·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦, ç›¸å‡å³ä¸ºå¹³è¡¡å› å­
> - å¦‚æœbfçš„ç»å¯¹å€¼å¤§äºç­‰äº2, åˆ™å…¨å±€å˜é‡+1

```c
typedef struct BTree {
	int data;
	int bf;
	struct BTree *lchid, *rchild;
}BTree;

int getHeight(BTree *T) {
	if(T == NULL)
		return 0;
	
	int leftH = getHeight(T->lchid);
	int rightH = getHeight(T->rchild);
	return leftH > rightH ? leftH+1 : rightH+1;
}

int unbalanced = 0;
void solution(BTree *T) {
	if(T == NULL)
		return 0;
		
	int leftH = getHeight(T->lchild);
	int rightH = getHeight(T->rchild);
	
	T->bf = leftH - rightH;
	
	if(T->bf <= -2 || T->bf >= 2)
		unbalanced +=1;
		
	solution(T->lchild);
	solution(T->rchild);
}
```

### 22. (æ·±åº¦å˜ç§)
é¢˜ç›®: å‡è®¾å¹³è¡¡äºŒå‰æ ‘çš„æ¯ä¸ªç»“ç‚¹è¡¨æ˜äº†å¹³è¡¡å› å­, æ±‚å¹³è¡¡äºŒå‰æ ‘çš„é«˜åº¦
```c
typedef struct BTree {
	int data;
	int bf;
	struct BTree *lchid, *rchild;
}BTree;

int getHeight(BTree *T) {
	if(T == NULL)
		return 0;
	
	return T->bf > 0  ? getHeight(T->lchild)+1 : getHeight(T->rchild)+1;
}
```

## ğŸ’«çº¿ç´¢äºŒå‰æ ‘



## ğŸ’«æ£®æ—



## ğŸ’«å…¶ä»–
### æ²¡çœ‹æ‡‚éƒ¨åˆ†
- è®²ä¹‰: 11


# â™¾ï¸å›¾
## ğŸ’«åŸºç¡€
### é‚»æ¥è¡¨å›¾ç»“æ„
```c
#define MAX_VERTEX_NUM 100  
  
typedef struct ArcNode {  
    int adjVex; // ç»“ç‚¹æ•°ç»„çš„ç´¢å¼•, ç”¨æ¥æŸ¥æ‰¾å…·ä½“çš„ç»“ç‚¹ä¿¡æ¯  
    struct ArcNode *nextArc;  
    int weight; // æƒé‡  
} ArcNode;  
  
typedef int VertexType;  
  
typedef struct VNode {  
    VertexType data;  
    ArcNode *firstArc; // ç¬¬ä¸€ä¸ªé‚»æ¥ç»“ç‚¹  
} VNode, AdjList[MAX_VERTEX_NUM];  
  
typedef struct {  
    VNode[] nodes; // æ‰€æœ‰ç»“ç‚¹  
    int vexNum; // ç»“ç‚¹æ•°, ä¹Ÿå³verticesæ•°ç»„é•¿åº¦  
    int arcNum; // æ€»çš„å¼§æ•°  
    int kind; // å›¾çš„ç±»å‹  
} ALGraph;
```

### DFSé€šè§£
```c
// è®¿é—®æ•°ç»„
int visited[VERTEX_NUM_MAX] = {0};

void DFS(ALGragh G, int v) {
	// å°†visitedæ•°ç»„ç½®ä¸º1
	visited[v] = 1;

	// è·å–é‚»æ¥ç»“ç‚¹
	ArcNode *adj = G.nodes[v].firstArc;
	while(adj != NULL) {
		if(visited[adj.adjVex] != 1) {
			DFS(G, adj.adjVex);
		}
		adj = adj.nextArc;
	}

	// å¦‚æœè¦å›é€€, åˆ™
	// visited[v] = 0;
}

void solution(ALGragh G) {
	for(int i = 0; i < vexNum; i++) {
		if(visited[i] != 1) {
			DFS(G, i);
		}
	}
}
```

### DFSè®°å½•è·¯å¾„é—®é¢˜
```c
int visited[VERTEX_NUM_MAX] = {0};
// è·¯å¾„è®°å½•
int aPath[VERTEX_NUM_MAX];
int len = 0; // è·¯å¾„æ•°ç»„çš„é•¿åº¦

void DFS(ALGragh G, int v) {
	visited[v] = 1;
	// å°†è¯¥è·¯å¾„ä¿å­˜åˆ°è·¯å¾„æ•°ç»„
	aPath[len] = v;
	len++;

	//å¤„ç†è·¯å¾„
	dealPath()...

	ArcNode *adj = G.nodes[v].firstArc;
	while(adj != NULL) {
		if(visited[adj.adjVex] != 1) {
			DFS(G, adj.adjVex);
		}
		adj = adj.nextArc;
	}

	// å›é€€ç»“ç‚¹
	visited[v] = 0;
	len--; // åˆ é™¤è·¯å¾„æ•°ç»„ä¸­çš„è·¯å¾„
}

```

### BFSé€šè§£
```c
int visited[VERTEX_NUM_MAX] = {0};

void BFS(ALGragh G, int v) {
	Queue Q;
	InitQueue(Q);
	int level = 1;
	enQueue(Q, v);
	int qLen = 1;

	while(qLen > 0) {
		int len = 0;

		for(int i = 0; i < qLen; i++) {
			int index;
			deQueue(Q, &index)

			VNode tmp = G.nodes[index];
			ArcNode *adj = G.nodes[v].firstArc;
			while(adj != NULL) {
				if(visited[adj.adjVex] != 1) {
					enQueue(Q, adj.adjVex);
					len++;
				}
			}
		}

		qLen = len;
	}
}
```


# â™¾ï¸äºŒå‰æ ‘çœŸé¢˜
## ğŸ’«è½¯ä»¶15
![[Pasted image 20241211144153.png]]

> æ ¸å¿ƒï¼šäºŒå‰æ ‘ç»“æ„ä½“åŒ…å«parentæŒ‡é’ˆ

```c
typedef struct BTree {
	ElemType data;
	struct *BTree lchild;
	struct *BTree rchild;
	struct *BTree parent;
}BTree;

void preOrder(BTree *T, ElemType x, BTree *parent) {
	if(T == NULL)
		return;
		
	T->parent = parent;
	
	if(x == T->data) {
		BTree *ancestor = T->parent;
		while(ancestor != NULL) {
			printf("%d ", ancestor->data);
			ancestor = ancestor->parent;
		}
	}
	
	preOrder(T->lchild, x, T);
	preOrder(T->rchild, x, T);
}
```


## ğŸ’«è½¯ä»¶16
![[Pasted image 20241211151544.png]]

```c
typedef struct BTree {
	ElemType data;
	struct *BTree lchild;
	struct *BTree rchild;
}BTree;

ElemType result = NULL;

void order(BTree *T, ElemType x) {
	if(T == NULL)
		return;
	
	if(T->data == x) {
		findValue(T);
		return;
	}
	if(x > T->data) {
		order(T->rchild, x);
		return;
	}
	if(x < T->data) {
		order(T->lchild, x);
	}
}

void findValue(BTree *T) {
	if(T == NULL)
		return;
		
	while(T->lchild != NULL) {
		T = T->lchild;
	}
	
	result = T->data;
}
```


## ğŸ’«@è½¯ä»¶17
å †æ’åºï¼


## ğŸ’«è½¯ä»¶18
![[Pasted image 20241212180407.png]]
```c
typedef struct BTree {
	ElemType data;
	struct *BTree lchild;
	struct *BTree rchild;
}BTree;

int result = 0;

void preOrder(BTree *T, ElemType x, int layer) {
	if(T == NULL)
		return;
		
	if(T->data == x) {
		result = layer;
		return;
	}
	
	preOrder(T->lchild, x, layer + 1);
	preOrder(T->rchild, x, layer + 1);
}

int solution(BTree *T, ElemType x) {
	preOrder(T, x, 1);
}
```


## ğŸ’«è½¯ä»¶19
![[Pasted image 20241212181313.png]]


![[Pasted image 20241212182401.png]]

```c
int getHeight(BTree *T) {
	if(T == NULL)
		return 0;
		
	if(T->lchild == NULL && T->rchild == NULL) {
		return 1;
	}
	
	int lheight = getHeight(T->lchild);
	int rheight = getHeight(T->rchild);
	
	return lheight > rheight ? lheight + 1 : rheight + 1;
}
```


## ğŸ’«è½¯ä»¶20
![[Pasted image 20241212182740.png]]
> æ ‡å‡†çš„å±‚åºéå†

## ğŸ’«è½¯ä»¶21
![[Pasted image 20241212190323.png]]

> å³ - ä¸­ - å·¦çš„é¡ºåºéå†äºŒå‰æ ‘

```c
BTree *result = NULL;
int curBig = 0;

void order(BTree *T, int n) {
	if(T == NULL)
		return;
		
	order(T->rchild, n);
	
	curBig++;
	if(curBig == n) {
		result = T;
		return;
	}
	
	order(T->lchild, n);
}
```
