# â™¾ï¸å•å…ƒæµ‹è¯•
## ðŸ’«åŸºç¡€

```java
import std.unittest.*
import std.unittest.testmacro.*

@Test
public class ToolTest {
    @TestCase
    public func testStringToInt() {
        let test1 = "123"
        @Expect(stringToInt(test1),123)

        let test2 = "123a"
        @ExpectThrows[Exception](stringToInt(test2))
    }
}
```

- @Expect
- @ExpectThrows

## ðŸ’«æƒ…å†µè®¨è®º
### æœ‰è¿”å›žå€¼çš„å‡½æ•°(åŸºç¡€)
```java
import std.unittest.*
import std.unittest.testmacro.*

@Test
public class ToolTest {
    @TestCase
    public func testStringToInt() {
        let test1 = "123"
        @Expect(stringToInt(test1),123)

        let test2 = "123a"
        @ExpectThrows[Exception](stringToInt(test2))
    }
}
```


# â™¾ï¸æ–‡ä»¶

```java
import std.fs.*
import std.io.*
import std.process.*
```

## ðŸ’«æ–‡ä»¶è·¯å¾„
> èŽ·å–src/config.json

```java
let curProcee = Process.current
let filePath = curProcee.workingDirectory.join("src").join("config.json")
if (!exists(filePath)) {
	throw FileNotExistException(filePath.toString())
}
```

## ðŸ’«è¯»å†™æ–‡ä»¶
> è¯»
```java
    let file = File(filePath, OpenMode.Read)

    try (myfile = StringReader(file)) {
        let info = myfile.readToEnd().toString()
    } finally {
        file.close()
    }
```

> å†™

```java
    let file = File(filePath, OpenMode.Write)
    try {
        let dm = cfg.serialize()
        let json = dm.toJson().toString()
        file.write(json.toArray())
    } finally {
        file.close()
    }
```


# â™¾ï¸å‡½æ•°
## ðŸ’«lambdaè¡¨è¾¾å¼
```java
        trie.addRoute(
            "GET",
            "/get/test",
            {
                ctx =>
                ctx.text200("get test")
                ctx.next()
            }
        )
```

















































