# â™¾ï¸é“¾è¡¨
## ğŸ’«ä¸¤æ•°ç›¸åŠ 
https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150

```ad-info
- å¯ä»¥å°†ä¸å¤Ÿé•¿çš„é“¾è¡¨å–0å€¼, è¿™æ ·å¯ä»¥èŠ‚çº¦å¾ˆå¤šè¡Œä»£ç 
```

```c
class Solution {
public:
    void insertTail(ListNode *head, int value) {
        auto *temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = new ListNode(value);
    }

    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        auto extra = 0; // è¿›ä½
        auto resultHead = new ListNode(0);

        while (l1 || l2) {
            int n1 = l1 ? l1->val : 0;
            int n2 = l2 ? l2->val : 0;
            int tempSum = n1 + n2 + extra;

            this->insertTail(resultHead, tempSum % 10);
            extra = tempSum / 10;

            if (l1)
                l1 = l1->next;
            if (l2)
                l2 = l2->next;
        }

        if (extra > 0) {
            insertTail(resultHead, extra);
        }

        return resultHead->next;
    }
};
```

## ğŸ’«åè½¬é“¾è¡¨
https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150

```ad-info
- æ³¨æ„ç»†èŠ‚
- ç„¶åå°±æ˜¯ç»™ä¼ å…¥çš„é“¾è¡¨åŠ ä¸Šä¸€ä¸ªå¤´èŠ‚ç‚¹, ä¼šèŠ‚çœå¾ˆå¤šéº»çƒ¦!!!
```

# â™¾ï¸äºŒå‰æ ‘
## ğŸ’«æœ€å¤§æ·±åº¦
```c
class Solution {  
public:  
    int depth(TreeNode *root) {  
        if (!root) {  
            return 0;  
        } else {  
            int l = depth(root->left);  
            int r = depth(root->right);  
  
            return 1 + (l > r ? l : r);  
        }  
    }  
  
    int maxDepth(TreeNode *root) {  
        return depth(root);  
    }  
};
```


# â™¾ï¸æ»‘åŠ¨çª—å£
https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-interview-150

```ad-info
- æ³¨æ„æ›´æ–°maxä»£ç çš„ä½ç½®, è€ƒè™‘æ•´ä¸ªå­—ç¬¦ä¸²éƒ½æ²¡æœ‰é‡å¤çš„æƒ…å†µ, å› æ­¤ä¸èƒ½æŠŠè¯¥ä»£ç æ”¾å…¥mapåˆ¤æ–­ä¸­
- æ³¨æ„slowçš„æ›´æ–°, æ›´æ–°çš„ä½ç½®ä¸èƒ½æ¯”slowå°!!!
```

```c
class Solution {  
public:  
    int lengthOfLongestSubstring(string s) {  
        if (s.size() == 0 || s.size() == 1) {  
            return s.size();  
        }  
  
        map<char, int> m;  
        int max = 0;  
  
        int slow = 0, fast = 1;  
        m.insert_or_assign(s[0], 0);  
        while (fast < s.size()) {  
            auto it = m.find(s[fast]);  
            if (it != m.end()) {  
                slow = it->second + 1 > slow ? it->second + 1 : slow;  
            }  
            max = fast - slow + 1 > max ? fast - slow + 1 : max;  
            m.insert_or_assign(s[fast], fast);  
            fast++;  
        }  
        return max;  
    }  
};
```



# â™¾ï¸å…¶ä»–
## ğŸ’«å±‚åºéå†æ¨¡æ¿
```c
	queue<TreeNode *> q;  
	if (root == nullptr) {  
	    return result;  
	}  
	  
	q.push(root);  
	while (!q.empty()) {  
	    int length = q.size();  
	    for (int i = 0; i < length; ++i) {  
	        auto tempNode = q.front();  
	        q.pop();  
	        if (tempNode->left != nullptr) {  
	            q.push(tempNode->left);  
	        }  
	        if (tempNode->right != nullptr) {  
	            q.push(tempNode->right);  
	        }  
	    }  
	  
	}
```
