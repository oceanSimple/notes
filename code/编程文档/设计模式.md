# â™¾ï¸å•ä¾‹æ¨¡å¼
## ğŸ’«æ‡’æ±‰å¼ä½æ•ˆå®ç°
```ad-error
é—®é¢˜ï¼šæ¯æ¬¡è°ƒç”¨GetInstanceå‡½æ•°ï¼Œéƒ½è¦åŠ é”è§£é”ï¼Œæµªè´¹æ€§èƒ½
```

```go
package main

import "fmt"

type singelton struct {}

var instance *singelton

func GetInstance() *singelton {
	//åªæœ‰é¦–æ¬¡GetInstance()æ–¹æ³•è¢«è°ƒç”¨ï¼Œæ‰ä¼šç”Ÿæˆè¿™ä¸ªå•ä¾‹çš„å®ä¾‹
	if instance == nil {
		instance = new(singelton)
		return instance
	}

	//æ¥ä¸‹æ¥çš„GetInstanceç›´æ¥è¿”å›å·²ç»ç”³è¯·çš„å®ä¾‹å³å¯
	return instance
}
```

## ğŸ’«æ‡’æ±‰å¼atomicä¼˜åŒ–
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

//æ ‡è®°
var initialized uint32
var lock sync.Mutex

type singelton struct {}

var instance *singelton

func GetInstance() *singelton {
	//å¦‚æœæ ‡è®°ä¸ºè¢«è®¾ç½®ï¼Œç›´æ¥è¿”å›ï¼Œä¸åŠ é”
	if atomic.LoadUint32(&initialized) == 1 {
		return instance
	}

	//å¦‚æœæ²¡æœ‰ï¼Œåˆ™åŠ é”ç”³è¯·
	lock.Lock()
	defer lock.Unlock()

	if initialized == 0 {
		instance = new(singelton)
		//è®¾ç½®æ ‡è®°ä½
		atomic.StoreUint32(&initialized, 1)
	}

	return instance
}
```

## ğŸ’«once.Doæœ€ä½³å®è·µ
```ad-info
once.Doå‡½æ•°å¸®æˆ‘ä»¬å®Œæˆäº†atomicçš„éƒ¨åˆ†
```
```go
func GetInstance() *singleTon {  
  
    once.Do(func() {  
       instance = new(singleTon)  
    })  
  
    return instance  
}
```

